{
    "docs": [
        {
            "location": "/", 
            "text": "VoxelGamesLib Documentation\n\n\nIntroduction\n\n\nVoxelGamesLib is a powerful, feature-packed, abstract and expandable Minecraft minigames framework.  \n\n\nVoxelGamesLib aims to divide people into 3 group: game developers, game designers, map builders.\n\n\nGame Developers\n\n\nGame developers will make use of the modular APIs VGL offers to make creating minigames pain free and allow them to focus on what's important: the gameplay.\n\n\nThe structure of VGL allows developers to easily write many games without having to repeat themselves. Game developers will focus on game logic and alow game designers to be able to configure the game in depth (covered in the next section).\n\n\nGame Designers\n\n\nGame designers do not need to know how to write Java; they can modify existing games just by editing values in a JSON file. That allows game designers to quickly try out new things without relying on a game developer. They can even make completly new games, just by combinding and configuring existing features.\n\n\nMainly, game designers will work with game developers. Game developers create the game logic, and game designers decide how that logic is implemented and transformed into what the player experiences. Game designers can create things like kits, adjust scoreboards, adjust phase times and swap features/phases around with ease.\n\n\nMap Builders\n\n\nMaps define the experience a player has in the game. Each map allows for a completely difference experience of the same game. VGL makes it easy for map builders to set up and configure maps.\n\n\nThey can setup their maps right from the game, marking important locations (spawns, chests, drop points, complex interactive structures, etc.) using skulls. Changes in map configurations, such as skulls, are reflected immediately in the game without input from a game developer or designer.\n\n\nServer Admins\n\n\nVGL isn't just a developer framework, it supports the server admins as well. VGL incorporates many functionalities such as a powerful roles system to allow server admins to manage their server with ease.\n\n\nPlayers\n\n\nPlayers make the game. VGL will allow players to easily play their favorite minigames, with support for stuff like elo based matchmaking and extensive stats tracking. They will also like that you have a seamless integration with consistency, every game UX is the same, making it easy to learn new modes.\n\n\nTo sum it up:\n\n\nwe care about every user of this framework, from the game developers up to the end users, and aim to provide the best experience possible for everyone.\n\n\nNext Steps\n\n\nIf you just want to skip to a certain part of the docs appropriate to your role, these links may help.\n\n\nGeneral:\n\n\n\n\nGetting started\n\n\nThe Doctrine\n\n\nContributing\n\n\n\n\nGame developers:\n\n\n\n\nDeveloper area\n\n\n\n\nGame designers:\n\n\n\n\nDesigner area\n\n\n\n\nMap builders:\n\n\n\n\nIntroduction to maps", 
            "title": "Introduction"
        }, 
        {
            "location": "/#voxelgameslib-documentation", 
            "text": "", 
            "title": "VoxelGamesLib Documentation"
        }, 
        {
            "location": "/#introduction", 
            "text": "VoxelGamesLib is a powerful, feature-packed, abstract and expandable Minecraft minigames framework.    VoxelGamesLib aims to divide people into 3 group: game developers, game designers, map builders.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#game-developers", 
            "text": "Game developers will make use of the modular APIs VGL offers to make creating minigames pain free and allow them to focus on what's important: the gameplay.  The structure of VGL allows developers to easily write many games without having to repeat themselves. Game developers will focus on game logic and alow game designers to be able to configure the game in depth (covered in the next section).", 
            "title": "Game Developers"
        }, 
        {
            "location": "/#game-designers", 
            "text": "Game designers do not need to know how to write Java; they can modify existing games just by editing values in a JSON file. That allows game designers to quickly try out new things without relying on a game developer. They can even make completly new games, just by combinding and configuring existing features.  Mainly, game designers will work with game developers. Game developers create the game logic, and game designers decide how that logic is implemented and transformed into what the player experiences. Game designers can create things like kits, adjust scoreboards, adjust phase times and swap features/phases around with ease.", 
            "title": "Game Designers"
        }, 
        {
            "location": "/#map-builders", 
            "text": "Maps define the experience a player has in the game. Each map allows for a completely difference experience of the same game. VGL makes it easy for map builders to set up and configure maps.  They can setup their maps right from the game, marking important locations (spawns, chests, drop points, complex interactive structures, etc.) using skulls. Changes in map configurations, such as skulls, are reflected immediately in the game without input from a game developer or designer.", 
            "title": "Map Builders"
        }, 
        {
            "location": "/#server-admins", 
            "text": "VGL isn't just a developer framework, it supports the server admins as well. VGL incorporates many functionalities such as a powerful roles system to allow server admins to manage their server with ease.", 
            "title": "Server Admins"
        }, 
        {
            "location": "/#players", 
            "text": "Players make the game. VGL will allow players to easily play their favorite minigames, with support for stuff like elo based matchmaking and extensive stats tracking. They will also like that you have a seamless integration with consistency, every game UX is the same, making it easy to learn new modes.", 
            "title": "Players"
        }, 
        {
            "location": "/#to-sum-it-up", 
            "text": "we care about every user of this framework, from the game developers up to the end users, and aim to provide the best experience possible for everyone.", 
            "title": "To sum it up:"
        }, 
        {
            "location": "/#next-steps", 
            "text": "If you just want to skip to a certain part of the docs appropriate to your role, these links may help.  General:   Getting started  The Doctrine  Contributing   Game developers:   Developer area   Game designers:   Designer area   Map builders:   Introduction to maps", 
            "title": "Next Steps"
        }, 
        {
            "location": "/general/doctrine/", 
            "text": "The VGL Doctrine\n\n\nCreating a minigame should be more about being focused with game logic and creating cool things,\nrather than focusing on rewriting tons of code and having to watch out for bugs all of the time.\n\n\nVGL takes away the crap associated with making a minigame and lets developers focus on creating\nsomething cool and focusing on game logic instead.\n\n\nWhat does this mean for you as a player? Developers can create new games faster, find bugs easier and \ngenerally are more motivated.\n\n\nWhat does this mean for you as a server admin? You can choose from a wide range of gamemodes without having to\ndeal with capability issues.\n\n\nVoxelGamesLib was made and is developed with certain fundamental ideas in mind.\nThis doctrine will help you better understand them. Keep these in mind as you write your own games extending VGL.\n\n\nModularity\n\n\nThis might be the most important concept. If you click around a bit on this documentation you will spot \nthe components VGL is made of. Its our number one priority to make sure that every piece of code you write can be \nreused elsewhere. \n\n\nIdeology 2\n\n\n...", 
            "title": "Doctrine"
        }, 
        {
            "location": "/general/doctrine/#the-vgl-doctrine", 
            "text": "Creating a minigame should be more about being focused with game logic and creating cool things,\nrather than focusing on rewriting tons of code and having to watch out for bugs all of the time.  VGL takes away the crap associated with making a minigame and lets developers focus on creating\nsomething cool and focusing on game logic instead.  What does this mean for you as a player? Developers can create new games faster, find bugs easier and \ngenerally are more motivated.  What does this mean for you as a server admin? You can choose from a wide range of gamemodes without having to\ndeal with capability issues.  VoxelGamesLib was made and is developed with certain fundamental ideas in mind.\nThis doctrine will help you better understand them. Keep these in mind as you write your own games extending VGL.", 
            "title": "The VGL Doctrine"
        }, 
        {
            "location": "/general/doctrine/#modularity", 
            "text": "This might be the most important concept. If you click around a bit on this documentation you will spot \nthe components VGL is made of. Its our number one priority to make sure that every piece of code you write can be \nreused elsewhere.", 
            "title": "Modularity"
        }, 
        {
            "location": "/general/doctrine/#ideology-2", 
            "text": "...", 
            "title": "Ideology 2"
        }, 
        {
            "location": "/general/getting-started/", 
            "text": "Getting Started\n\n\nHopefully you've already read the doctrine to have a better understanding of the concepts and ideology behind VGL. The rest of the guide will assume you have an understanding of VGL concepts listed in the doctrine, such as a phase-oriented design.\n\n\nHere are some of the things that VGL does for you:\n\n\n\n\nFair, elo-based matchmaking\n\n\nRoles\n\n\nLocales\n\n\nPersistence\n\n\n\n\nVGL also contains many APIs to assist with development, for example:\n\n\n\n\nScoreboard API\n\n\nSign API\n\n\n\n\nThe next section will go on to talk about the key components that make up games in VGL:\n\n\n\n\nPhases\n\n\nFeatures", 
            "title": "Getting started"
        }, 
        {
            "location": "/general/getting-started/#getting-started", 
            "text": "Hopefully you've already read the doctrine to have a better understanding of the concepts and ideology behind VGL. The rest of the guide will assume you have an understanding of VGL concepts listed in the doctrine, such as a phase-oriented design.  Here are some of the things that VGL does for you:   Fair, elo-based matchmaking  Roles  Locales  Persistence   VGL also contains many APIs to assist with development, for example:   Scoreboard API  Sign API   The next section will go on to talk about the key components that make up games in VGL:   Phases  Features", 
            "title": "Getting Started"
        }, 
        {
            "location": "/general/terms/", 
            "text": "Terms\n\n\nWhen dealing with VoxelGamesLib you will stumble upon a bunch of terms\nand abbreviations. This place aims to be a central page to explain those\n\n\n\n\nVGL\n\n\nAbbreviation for this project, VoxelGamesLib\n\n\n\n\n\n\nPhase\n\n\nA phase in a game is a timespan where certain gameplay parts (Features)\nare active. It can end after a special time or after a certain condition\n\n\n\n\n\n\nFeature\n\n\nFeature often refers to a certain small, modular set of logic that is\nused to build phases and games. A feature can be nearly everything, from\ndisabling PVP or blocking block break to complex spawn or team selection \nalgorithms.\n\n\n\n\n\n\nGamemode\n\n\na gamemode is what people can play. it contains multiple phases. \n\n\n\n\n\n\nPR\n\n\nPull request, used when somebody wants to make changes to any of the projects\nrepos.\n\n\n\n\n\n\nRepo\n\n\nRepository. Basically projects hosted on github.\n\n\n\n\n\n\nGame Developer\n\n\nSomeone who extends VGL by writing phases, features or games using the API VGL provides.\n\n\n\n\n\n\nGame Designer\n\n\nSomeone who uses game definitions to custimize games and remix entrily new games.\n\n\n\n\n\n\nMap Builder\n\n\nSomeone who builds maps and uses the world creator in VGL to add it into the system so that games can use them.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou stumbled upon a term that is not listed here? Open a PR to add it or \nopen an issue so ppl can explain it to you (and add it here later)", 
            "title": "Terms"
        }, 
        {
            "location": "/general/terms/#terms", 
            "text": "When dealing with VoxelGamesLib you will stumble upon a bunch of terms\nand abbreviations. This place aims to be a central page to explain those   VGL  Abbreviation for this project, VoxelGamesLib    Phase  A phase in a game is a timespan where certain gameplay parts (Features)\nare active. It can end after a special time or after a certain condition    Feature  Feature often refers to a certain small, modular set of logic that is\nused to build phases and games. A feature can be nearly everything, from\ndisabling PVP or blocking block break to complex spawn or team selection \nalgorithms.    Gamemode  a gamemode is what people can play. it contains multiple phases.     PR  Pull request, used when somebody wants to make changes to any of the projects\nrepos.    Repo  Repository. Basically projects hosted on github.    Game Developer  Someone who extends VGL by writing phases, features or games using the API VGL provides.    Game Designer  Someone who uses game definitions to custimize games and remix entrily new games.    Map Builder  Someone who builds maps and uses the world creator in VGL to add it into the system so that games can use them.      Tip  You stumbled upon a term that is not listed here? Open a PR to add it or \nopen an issue so ppl can explain it to you (and add it here later)", 
            "title": "Terms"
        }, 
        {
            "location": "/components/general/", 
            "text": "Components\n\n\nThere are 4 types of components in VGL\n\n\n\n\n\n\nFeatures\n\n  Feature often refers to a certain small, modular set of logic that is\n  used to build phases and games. A feature can be nearly everything, from\n  disabling PVP or blocking block break to complex spawn or team selection \n  algorithms.\n\n  You can find a list of features \nhere\n\n\n\n\n\n\nPhases\n\n  A phase in a game is a timespan where certain gameplay parts (Features)\n  are active. It can end after a special time or after a certain condition.\n\n  You can find a list of phases \nhere\n\n\n\n\n\n\nGames\n\n  a game or gamemode is what people can play. it contains multiple phases.\n  You can find a list of gamemodes \nhere\n\n\n\n\n\n\nVictory Conditions\n\n  Victory conditions are a way to end a game, once reached. \n  You can find a list of victory conditions \nhere", 
            "title": "General"
        }, 
        {
            "location": "/components/general/#components", 
            "text": "There are 4 types of components in VGL    Features \n  Feature often refers to a certain small, modular set of logic that is\n  used to build phases and games. A feature can be nearly everything, from\n  disabling PVP or blocking block break to complex spawn or team selection \n  algorithms. \n  You can find a list of features  here    Phases \n  A phase in a game is a timespan where certain gameplay parts (Features)\n  are active. It can end after a special time or after a certain condition. \n  You can find a list of phases  here    Games \n  a game or gamemode is what people can play. it contains multiple phases.\n  You can find a list of gamemodes  here    Victory Conditions \n  Victory conditions are a way to end a game, once reached. \n  You can find a list of victory conditions  here", 
            "title": "Components"
        }, 
        {
            "location": "/components/features/", 
            "text": "Features\n\n\nThere is not much here yet, but in the future this will be the place\nwhere all features are listed and its parameters explained.\nThis may also contain links and documentation for 3\nrd\n party features.\n\n\n[features]\n\n\nAutoRespawnFeature (com.voxelgameslib.voxelgameslib.feature.features.AutoRespawnFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Makes dead players respawn automatically  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nBleedFeature (com.voxelgameslib.voxelgameslib.feature.features.BleedFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Displays a bleed effect around the player  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nChannelFeature (com.voxelgameslib.voxelgameslib.feature.features.ChannelFeature) v1.0\n\n\nAuthor: aphel\n\nDescription: Adds support for multiple channels in phases, e.g. for team based chats  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nClearInventoryFeature (com.voxelgameslib.voxelgameslib.feature.features.ClearInventoryFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Simple feature that clears the inventory of all players when the game starts (or a new player joins)  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nDoubleJumpFeature (com.voxelgameslib.voxelgameslib.feature.features.DoubleJumpFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Lets player jump higher  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nGameModeFeature (com.voxelgameslib.voxelgameslib.feature.features.GameModeFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Simple feature that changes the gamemode of all players in the phase  \n\n\nParams\n\n\nmode (org.bukkit.GameMode)  \n\n\nDependencies\n\n\nSoft Dependencies\n\n\nHealFeature (com.voxelgameslib.voxelgameslib.feature.features.HealFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Small feature that heals and feeds players on join  \n\n\nParams\n\n\nheal (boolean)\n\nfeed (boolean)  \n\n\nDependencies\n\n\nSoft Dependencies\n\n\nJumpPad (com.voxelgameslib.voxelgameslib.feature.features.JumpPadFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Lets players use pressure plates to get launched up in the sky  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nMapFeature (com.voxelgameslib.voxelgameslib.feature.features.MapFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Handles loading and unloading of the map for this phase  \n\n\nParams\n\n\nshouldUnload (boolean)\n\ntype (com.voxelgameslib.voxelgameslib.feature.features.MapFeature$Type)  \n\n\nDependencies\n\n\nSoft Dependencies\n\n\nMapInfoFeature (com.voxelgameslib.voxelgameslib.feature.features.MapInfoFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Displays some information about the current map in the scoreboard of the phase  \n\n\nParams\n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.MapFeature\n\ncom.voxelgameslib.voxelgameslib.feature.features.ScoreboardFeature  \n\n\nSoft Dependencies\n\n\nNoBlockBreakFeature (com.voxelgameslib.voxelgameslib.feature.features.NoBlockBreakFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Small feature that blocks block breaking if active  \n\n\nParams\n\n\nwhitelist ([Lorg.bukkit.Material;)\n\nblacklist ([Lorg.bukkit.Material;)  \n\n\nDependencies\n\n\nSoft Dependencies\n\n\nNoBlockPlaceFeature (com.voxelgameslib.voxelgameslib.feature.features.NoBlockPlaceFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Small feature that blocks block placing if active  \n\n\nParams\n\n\nwhitelist ([Lorg.bukkit.Material;)\n\nblacklist ([Lorg.bukkit.Material;)  \n\n\nDependencies\n\n\nSoft Dependencies\n\n\nNoDamageFeature (com.voxelgameslib.voxelgameslib.feature.features.NoDamageFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Small feature that disables any damage  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nNoHungerLossFeature (com.voxelgameslib.voxelgameslib.feature.features.NoHungerLossFeature) v1.0\n\n\nAuthor: aphelion\n\nDescription: Stops hunger loss  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nNoTimeChangeFeature (com.voxelgameslib.voxelgameslib.feature.features.NoTimeChangeFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Locks the time  \n\n\nParams\n\n\ntime (long)  \n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.MapFeature  \n\n\nSoft Dependencies\n\n\nNoWeatherChangeFeature (com.voxelgameslib.voxelgameslib.feature.features.NoWeatherChangeFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Locks the weather  \n\n\nParams\n\n\nweather (org.bukkit.WeatherType)  \n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.MapFeature  \n\n\nSoft Dependencies\n\n\nPersonalScoreboard (com.voxelgameslib.voxelgameslib.feature.features.PersonalScoreboardFeature) v1.0\n\n\nAuthor: aphel\n\nDescription: Each player has their own individual scoreboard  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nPostGameFeature (com.voxelgameslib.voxelgameslib.feature.features.PostGameFeature) v1.0\n\n\nAuthor: aphelion\n\nDescription: Implements post-game logic  \n\n\nParams\n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.PersonalScoreboardFeature  \n\n\nSoft Dependencies\n\n\nScoreboardFeature (com.voxelgameslib.voxelgameslib.feature.features.ScoreboardFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Handles the scoreboard for all other features  \n\n\nParams\n\n\nDependencies\n\n\nSoft Dependencies\n\n\nSpawnFeature (com.voxelgameslib.voxelgameslib.feature.features.SpawnFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Handles (re)spawning  \n\n\nParams\n\n\nisRespawn (boolean)\n\nisInitialSpawn (boolean)  \n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.MapFeature  \n\n\nSoft Dependencies\n\n\nVoidTeleportFeature (com.voxelgameslib.voxelgameslib.feature.features.VoidTeleportFeature) v1.0\n\n\nAuthor: aphel\n\nDescription: Teleports player to spawn if they fall into the void  \n\n\nParams\n\n\nDependencies\n\n\ncom.voxelgameslib.voxelgameslib.feature.features.SpawnFeature  \n\n\nSoft Dependencies\n\n\nVoteFeature (com.voxelgameslib.voxelgameslib.feature.features.VoteFeature) v1.0\n\n\nAuthor: MiniDigger\n\nDescription: Allow players to vote on maps  \n\n\nParams\n\n\nmaxMaps (int)\n\nenableVoteMenu (boolean)  \n\n\nDependencies\n\n\nSoft Dependencies", 
            "title": "Features"
        }, 
        {
            "location": "/components/features/#features", 
            "text": "There is not much here yet, but in the future this will be the place\nwhere all features are listed and its parameters explained.\nThis may also contain links and documentation for 3 rd  party features.  [features]", 
            "title": "Features"
        }, 
        {
            "location": "/components/features/#autorespawnfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesautorespawnfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Makes dead players respawn automatically", 
            "title": "AutoRespawnFeature (com.voxelgameslib.voxelgameslib.feature.features.AutoRespawnFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#bleedfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesbleedfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Displays a bleed effect around the player", 
            "title": "BleedFeature (com.voxelgameslib.voxelgameslib.feature.features.BleedFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_1", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_1", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_1", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#channelfeature-comvoxelgameslibvoxelgameslibfeaturefeatureschannelfeature-v10", 
            "text": "Author: aphel \nDescription: Adds support for multiple channels in phases, e.g. for team based chats", 
            "title": "ChannelFeature (com.voxelgameslib.voxelgameslib.feature.features.ChannelFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_2", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_2", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_2", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#clearinventoryfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesclearinventoryfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Simple feature that clears the inventory of all players when the game starts (or a new player joins)", 
            "title": "ClearInventoryFeature (com.voxelgameslib.voxelgameslib.feature.features.ClearInventoryFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_3", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_3", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_3", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#doublejumpfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesdoublejumpfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Lets player jump higher", 
            "title": "DoubleJumpFeature (com.voxelgameslib.voxelgameslib.feature.features.DoubleJumpFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_4", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_4", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_4", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#gamemodefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesgamemodefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Simple feature that changes the gamemode of all players in the phase", 
            "title": "GameModeFeature (com.voxelgameslib.voxelgameslib.feature.features.GameModeFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_5", 
            "text": "mode (org.bukkit.GameMode)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_5", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_5", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#healfeature-comvoxelgameslibvoxelgameslibfeaturefeatureshealfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Small feature that heals and feeds players on join", 
            "title": "HealFeature (com.voxelgameslib.voxelgameslib.feature.features.HealFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_6", 
            "text": "heal (boolean) \nfeed (boolean)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_6", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_6", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#jumppad-comvoxelgameslibvoxelgameslibfeaturefeaturesjumppadfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Lets players use pressure plates to get launched up in the sky", 
            "title": "JumpPad (com.voxelgameslib.voxelgameslib.feature.features.JumpPadFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_7", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_7", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_7", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#mapfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesmapfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Handles loading and unloading of the map for this phase", 
            "title": "MapFeature (com.voxelgameslib.voxelgameslib.feature.features.MapFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_8", 
            "text": "shouldUnload (boolean) \ntype (com.voxelgameslib.voxelgameslib.feature.features.MapFeature$Type)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_8", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_8", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#mapinfofeature-comvoxelgameslibvoxelgameslibfeaturefeaturesmapinfofeature-v10", 
            "text": "Author: MiniDigger \nDescription: Displays some information about the current map in the scoreboard of the phase", 
            "title": "MapInfoFeature (com.voxelgameslib.voxelgameslib.feature.features.MapInfoFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_9", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_9", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.MapFeature \ncom.voxelgameslib.voxelgameslib.feature.features.ScoreboardFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_9", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#noblockbreakfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnoblockbreakfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Small feature that blocks block breaking if active", 
            "title": "NoBlockBreakFeature (com.voxelgameslib.voxelgameslib.feature.features.NoBlockBreakFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_10", 
            "text": "whitelist ([Lorg.bukkit.Material;) \nblacklist ([Lorg.bukkit.Material;)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_10", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_10", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#noblockplacefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnoblockplacefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Small feature that blocks block placing if active", 
            "title": "NoBlockPlaceFeature (com.voxelgameslib.voxelgameslib.feature.features.NoBlockPlaceFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_11", 
            "text": "whitelist ([Lorg.bukkit.Material;) \nblacklist ([Lorg.bukkit.Material;)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_11", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_11", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#nodamagefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnodamagefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Small feature that disables any damage", 
            "title": "NoDamageFeature (com.voxelgameslib.voxelgameslib.feature.features.NoDamageFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_12", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_12", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_12", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#nohungerlossfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnohungerlossfeature-v10", 
            "text": "Author: aphelion \nDescription: Stops hunger loss", 
            "title": "NoHungerLossFeature (com.voxelgameslib.voxelgameslib.feature.features.NoHungerLossFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_13", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_13", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_13", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#notimechangefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnotimechangefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Locks the time", 
            "title": "NoTimeChangeFeature (com.voxelgameslib.voxelgameslib.feature.features.NoTimeChangeFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_14", 
            "text": "time (long)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_14", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.MapFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_14", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#noweatherchangefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesnoweatherchangefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Locks the weather", 
            "title": "NoWeatherChangeFeature (com.voxelgameslib.voxelgameslib.feature.features.NoWeatherChangeFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_15", 
            "text": "weather (org.bukkit.WeatherType)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_15", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.MapFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_15", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#personalscoreboard-comvoxelgameslibvoxelgameslibfeaturefeaturespersonalscoreboardfeature-v10", 
            "text": "Author: aphel \nDescription: Each player has their own individual scoreboard", 
            "title": "PersonalScoreboard (com.voxelgameslib.voxelgameslib.feature.features.PersonalScoreboardFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_16", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_16", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_16", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#postgamefeature-comvoxelgameslibvoxelgameslibfeaturefeaturespostgamefeature-v10", 
            "text": "Author: aphelion \nDescription: Implements post-game logic", 
            "title": "PostGameFeature (com.voxelgameslib.voxelgameslib.feature.features.PostGameFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_17", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_17", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.PersonalScoreboardFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_17", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#scoreboardfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesscoreboardfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Handles the scoreboard for all other features", 
            "title": "ScoreboardFeature (com.voxelgameslib.voxelgameslib.feature.features.ScoreboardFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_18", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_18", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_18", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#spawnfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesspawnfeature-v10", 
            "text": "Author: MiniDigger \nDescription: Handles (re)spawning", 
            "title": "SpawnFeature (com.voxelgameslib.voxelgameslib.feature.features.SpawnFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_19", 
            "text": "isRespawn (boolean) \nisInitialSpawn (boolean)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_19", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.MapFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_19", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#voidteleportfeature-comvoxelgameslibvoxelgameslibfeaturefeaturesvoidteleportfeature-v10", 
            "text": "Author: aphel \nDescription: Teleports player to spawn if they fall into the void", 
            "title": "VoidTeleportFeature (com.voxelgameslib.voxelgameslib.feature.features.VoidTeleportFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_20", 
            "text": "", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_20", 
            "text": "com.voxelgameslib.voxelgameslib.feature.features.SpawnFeature", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_20", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/features/#votefeature-comvoxelgameslibvoxelgameslibfeaturefeaturesvotefeature-v10", 
            "text": "Author: MiniDigger \nDescription: Allow players to vote on maps", 
            "title": "VoteFeature (com.voxelgameslib.voxelgameslib.feature.features.VoteFeature) v1.0"
        }, 
        {
            "location": "/components/features/#params_21", 
            "text": "maxMaps (int) \nenableVoteMenu (boolean)", 
            "title": "Params"
        }, 
        {
            "location": "/components/features/#dependencies_21", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/components/features/#soft-dependencies_21", 
            "text": "", 
            "title": "Soft Dependencies"
        }, 
        {
            "location": "/components/phases/", 
            "text": "Phases\n\n\nThere is not much here yet, but in the future this will be the place\nwhere all phases are listed and its parameters explained.\nThis may also contain links and documentation for 3\nrd\n party phases.", 
            "title": "Phases"
        }, 
        {
            "location": "/components/phases/#phases", 
            "text": "There is not much here yet, but in the future this will be the place\nwhere all phases are listed and its parameters explained.\nThis may also contain links and documentation for 3 rd  party phases.", 
            "title": "Phases"
        }, 
        {
            "location": "/components/games/", 
            "text": "Games\n\n\nThere is not much here yet, but in the future this will be the place\nwhere all public games are listed and explained.", 
            "title": "Games"
        }, 
        {
            "location": "/components/games/#games", 
            "text": "There is not much here yet, but in the future this will be the place\nwhere all public games are listed and explained.", 
            "title": "Games"
        }, 
        {
            "location": "/components/victoryconditions/", 
            "text": "Victory Conditions\n\n\nVictory conditions are a way to end a game, once reached. \n\n\n[conditions]\ntodo write conditions", 
            "title": "VictoryConditions"
        }, 
        {
            "location": "/components/victoryconditions/#victory-conditions", 
            "text": "Victory conditions are a way to end a game, once reached.   [conditions]\ntodo write conditions", 
            "title": "Victory Conditions"
        }, 
        {
            "location": "/maps/introduction/", 
            "text": "Introduction\n\n\nVoxelGamesLib allows map makers to easily build, configure and share their maps. These pages aim to explain on how you do exactly that.\n\n\nGuidelines\n\n\nThere are some tips and guidelines on how to make a good map:\n\n\nUse a void world\n\n\nVoxelGamesLib will load all worlds with a void world generator, to minimize chunk generation and loading impact. You should build your maps in a void world, or move it into a void world using mcedit.\n\nWhile in mcedit, also make sure to truncate any extra chunks to reduce file size.\n\n\nBuild your map for many modes\n\n\nIn VGL you will be defining special locations in your world via named player skulls. You should make sure to put as many as possible to allow your map to be played with multiple gamemodes.\n\nFor example: your 1vs1 map might need only 1 spawn for each team, but if you add more, users could also play 2vs2 or even 4vs4 based gamemodes on it.\n\nDon't worry, VGL will only allow your map to be played with the gamemodes you defined and tested to make sure that players will have a good experience.\n\n\nIterate on your design\n\n\nVGL allows you to quickly make changes to your maps, without needing to go thru all the pain of setting it up again. You can quickly add new positions or modify the world.\n\nYou should use this to improve your maps over time. Listen to player feedback or just watch them play and think about how you can improve your maps.\n\n\nShare your maps\n\n\nThe VGL believes in the power of open source. You take and you give, sharing is caring, you know all those sayings. Many map makers already shared their maps and every server is allowed to use them, so its only fair to share\nyour stuff too. That way, you can build up a reputation in the community and allow more players to enjoy your maps, and after all, thats why we do all of this, right?", 
            "title": "Introduction"
        }, 
        {
            "location": "/maps/introduction/#introduction", 
            "text": "VoxelGamesLib allows map makers to easily build, configure and share their maps. These pages aim to explain on how you do exactly that.", 
            "title": "Introduction"
        }, 
        {
            "location": "/maps/introduction/#guidelines", 
            "text": "There are some tips and guidelines on how to make a good map:", 
            "title": "Guidelines"
        }, 
        {
            "location": "/maps/introduction/#use-a-void-world", 
            "text": "VoxelGamesLib will load all worlds with a void world generator, to minimize chunk generation and loading impact. You should build your maps in a void world, or move it into a void world using mcedit. \nWhile in mcedit, also make sure to truncate any extra chunks to reduce file size.", 
            "title": "Use a void world"
        }, 
        {
            "location": "/maps/introduction/#build-your-map-for-many-modes", 
            "text": "In VGL you will be defining special locations in your world via named player skulls. You should make sure to put as many as possible to allow your map to be played with multiple gamemodes. \nFor example: your 1vs1 map might need only 1 spawn for each team, but if you add more, users could also play 2vs2 or even 4vs4 based gamemodes on it. \nDon't worry, VGL will only allow your map to be played with the gamemodes you defined and tested to make sure that players will have a good experience.", 
            "title": "Build your map for many modes"
        }, 
        {
            "location": "/maps/introduction/#iterate-on-your-design", 
            "text": "VGL allows you to quickly make changes to your maps, without needing to go thru all the pain of setting it up again. You can quickly add new positions or modify the world. \nYou should use this to improve your maps over time. Listen to player feedback or just watch them play and think about how you can improve your maps.", 
            "title": "Iterate on your design"
        }, 
        {
            "location": "/maps/introduction/#share-your-maps", 
            "text": "The VGL believes in the power of open source. You take and you give, sharing is caring, you know all those sayings. Many map makers already shared their maps and every server is allowed to use them, so its only fair to share\nyour stuff too. That way, you can build up a reputation in the community and allow more players to enjoy your maps, and after all, thats why we do all of this, right?", 
            "title": "Share your maps"
        }, 
        {
            "location": "/maps/how-to-create-a-map/", 
            "text": "How to create a map\n\n\nThis page aims to explain how to create a map and get it into the VGL system.\n\n\nTODO: add pictures and a video\n\n\nBuilding your map\n\n\nWe recommend you to build your map on a dedicated build server. That way you can throw all your Worldedits and Voxelsnipers on there and using them without fearing any interference. \nIf you work alone, you can just setup a local server, since you will need to use mcedit to delete chunks, this saves you from downloading the map.\n\nWhile building, think about where special positions like spawns or objectives should be located. You don't need to set them now, but you will need to do that when you import the map into VGL.  \n\n\nImporting into VGL\n\n\nOnce you builded your map, add it to a server which has VGL installed. This can be a local server or a remote test server. I wouldn't recommend to do this on a production server, but it should work too.\n\nJust place the map in the root foler of your server, next to the world and world_nether folders.\n\nVGL has a chat based wizard like interface to import your map. Start it with \n/wc start\n.    \n\n\n\n\nYou will see a promt asking you for the name. Click the promt and enter the name of the world (the name of the folder you uploaded). \n    Don't worry, this is not the display name players will see.  \n\n\nThis will start the edit mode and you will be teleported to the world spawn.\n\n    The edit mode is similar to other gamemodes VGL offers, but you are not expected to show off your PvP abilities here. This mode is designed to allow you to easily modify the special locations of the map.\n\n    You will now see a promt to select the center of the map. This is not the spawn for the players, this is only used for scanning for markers and preloading chunks.\n\n\nOnce you set a center, you will be promted to select the radius. Again, just for internal stuff, it doesn't really need to be percice, if you set it too large, creating the world might take some time.\n\n\nAfter setting the radius, you will be asked for a display name. This is the name the players will see. \n\n\nNow that you have the name set, you can set the author. This can be your name, a list of names or the name of your build team. It doesn't really matter, its just a nice way of crediting the creators.\n\n\nNow we have all that done, we can configure the gamemodes. The wizard will show you a list of all currently installed gamemodes, you can select one by clicking it. Once you selected all gamemodes, press done.\n\n\nNow we can get to the fun part: setting all markers. Enable the edit mode by clicking on the promt or running \n/wc edit on\n.\n\n    You now can set markers. To learn what marker does what, check the documentation of the game modes. The easiest way to get markers is running \n/editmode gui\n. \n    You will see a gui with all known (all markers of all features that are currently loaded), click one to get the item, place one to set a marker. Pretty easy, eh?\n\n    Once you set all markers, finish the world import by running \n/wc edit off\n. Don't worry if you forgot a marker or smth, you can always edit your map later to add more. \n\n\nYou are done now. You will see a nice summary and a promt to finish. Once you press that, VGL will write all your config into a config.json, it will scan for all your placed markers, zip everything up and upload it into your world repositiory. \n    The edit mode gamemode will abort now.", 
            "title": "How to create a map"
        }, 
        {
            "location": "/maps/how-to-create-a-map/#how-to-create-a-map", 
            "text": "This page aims to explain how to create a map and get it into the VGL system.  TODO: add pictures and a video", 
            "title": "How to create a map"
        }, 
        {
            "location": "/maps/how-to-create-a-map/#building-your-map", 
            "text": "We recommend you to build your map on a dedicated build server. That way you can throw all your Worldedits and Voxelsnipers on there and using them without fearing any interference. \nIf you work alone, you can just setup a local server, since you will need to use mcedit to delete chunks, this saves you from downloading the map. \nWhile building, think about where special positions like spawns or objectives should be located. You don't need to set them now, but you will need to do that when you import the map into VGL.", 
            "title": "Building your map"
        }, 
        {
            "location": "/maps/how-to-create-a-map/#importing-into-vgl", 
            "text": "Once you builded your map, add it to a server which has VGL installed. This can be a local server or a remote test server. I wouldn't recommend to do this on a production server, but it should work too. \nJust place the map in the root foler of your server, next to the world and world_nether folders. \nVGL has a chat based wizard like interface to import your map. Start it with  /wc start .       You will see a promt asking you for the name. Click the promt and enter the name of the world (the name of the folder you uploaded). \n    Don't worry, this is not the display name players will see.    This will start the edit mode and you will be teleported to the world spawn. \n    The edit mode is similar to other gamemodes VGL offers, but you are not expected to show off your PvP abilities here. This mode is designed to allow you to easily modify the special locations of the map. \n    You will now see a promt to select the center of the map. This is not the spawn for the players, this is only used for scanning for markers and preloading chunks.  Once you set a center, you will be promted to select the radius. Again, just for internal stuff, it doesn't really need to be percice, if you set it too large, creating the world might take some time.  After setting the radius, you will be asked for a display name. This is the name the players will see.   Now that you have the name set, you can set the author. This can be your name, a list of names or the name of your build team. It doesn't really matter, its just a nice way of crediting the creators.  Now we have all that done, we can configure the gamemodes. The wizard will show you a list of all currently installed gamemodes, you can select one by clicking it. Once you selected all gamemodes, press done.  Now we can get to the fun part: setting all markers. Enable the edit mode by clicking on the promt or running  /wc edit on . \n    You now can set markers. To learn what marker does what, check the documentation of the game modes. The easiest way to get markers is running  /editmode gui . \n    You will see a gui with all known (all markers of all features that are currently loaded), click one to get the item, place one to set a marker. Pretty easy, eh? \n    Once you set all markers, finish the world import by running  /wc edit off . Don't worry if you forgot a marker or smth, you can always edit your map later to add more.   You are done now. You will see a nice summary and a promt to finish. Once you press that, VGL will write all your config into a config.json, it will scan for all your placed markers, zip everything up and upload it into your world repositiory. \n    The edit mode gamemode will abort now.", 
            "title": "Importing into VGL"
        }, 
        {
            "location": "/maps/how-to-edit-a-map/", 
            "text": "How to edit a map\n\n\nThis page aims to explain how to edit a map, once it was addded to a world repository. \n\n\nTODO: add images and a vid.\n\n\nWorldCreator Modify Mode\n\n\nYou can enter the edit mode again by running \n/wc m start \nworldname\n. VGL will get the world, unzip it and load it, while teleporting you to the center. \n\n\nNow you can utilize a bunch of commands to modify the world. You an use \n/wc m\n with the subcommands \ndisplayname\n, \nauthor\n, \nradius\n, \ncenter\n or \ngamemode\n to change those.  \n\n\nTo change markers (they should be currently visible), enter \n/editmode on\n and use the same commands you know already.  \n\n\nOnce you are done, run \n/editmode off\n and \n/wc m stop\n to stop editing. This will let VGL do all the packaging, saving and uploading again and the changed map will be available to be used in games.", 
            "title": "How to edit a map"
        }, 
        {
            "location": "/maps/how-to-edit-a-map/#how-to-edit-a-map", 
            "text": "This page aims to explain how to edit a map, once it was addded to a world repository.   TODO: add images and a vid.", 
            "title": "How to edit a map"
        }, 
        {
            "location": "/maps/how-to-edit-a-map/#worldcreator-modify-mode", 
            "text": "You can enter the edit mode again by running  /wc m start  worldname . VGL will get the world, unzip it and load it, while teleporting you to the center.   Now you can utilize a bunch of commands to modify the world. You an use  /wc m  with the subcommands  displayname ,  author ,  radius ,  center  or  gamemode  to change those.    To change markers (they should be currently visible), enter  /editmode on  and use the same commands you know already.    Once you are done, run  /editmode off  and  /wc m stop  to stop editing. This will let VGL do all the packaging, saving and uploading again and the changed map will be available to be used in games.", 
            "title": "WorldCreator Modify Mode"
        }, 
        {
            "location": "/designer-area/", 
            "text": "Game Designers\n\n\n...", 
            "title": "Index"
        }, 
        {
            "location": "/designer-area/#game-designers", 
            "text": "...", 
            "title": "Game Designers"
        }, 
        {
            "location": "/developer-area/how-to-write-an-addon/", 
            "text": "How to write an addon\n\n\nAn addon to VGL is just a normal bukkit plugin with some extra stuff.\n\nWe will be looking at the 1vs1 game as an example, you can find the full (and updated) code \nhere\n\nYour mainclass is pretty straight forward. You want to extend JavaPlugin as usual, but also implement Module (from VGL).\nYou also should mark the class @Singleton and add a @ModuleInfo\n\n1\n2\n3\n@Singleton\n\n\n@ModuleInfo\n(\nname\n \n=\n \n1vs1\n,\n \nauthors\n \n=\n \nMiniDigger\n,\n \nversion\n \n=\n \n1.0.0\n)\n\n\npublic\n \nclass\n \nOneVsOnePlugin\n \nextends\n \nJavaPlugin\n \nimplements\n \nModule\n\n\n\n\n\nThe most important thing is that you add a onLoad that looks like this:\n\n1\n2\n3\n4\n    \n@Override\n\n    \npublic\n \nvoid\n \nonLoad\n()\n \n{\n\n        \nModuleHandler\n.\nofferModule\n(\nthis\n);\n \n// always do this first!\n\n    \n}\n\n\n\n\n\nThis is the part where your addon hooks into VGL. you want to ignore bukkits onEnable and onDisable and use VGL's enable and disable instead.\nThis will make sure, that you don't do stuff before VGL has initialized your module properly.\n\nAfter the module has been initalized, you can easly access any part of VGL via guice injections.\n\nIf you are new to guice, check out this short introduction \nhere\n \n\n\nIf your addon offers a new gamemode, you also should register that in your main file.\n\nAdd a constant called GAMEMODE to hold a reference to your gamemode:\n\n1\npublic\n \nstatic\n \nfinal\n \nGameMode\n \nGAMEMODE\n \n=\n \nnew\n \nGameMode\n(\n1vs1\n,\n \nOneVsOneGame\n.\nclass\n);\n\n\n\n\n\nthen register that in your enable method:\n\n1\n2\n3\n4\n    \n@Override\n\n    \npublic\n \nvoid\n \nenable\n()\n \n{\n\n        \ngameHandler\n.\nregisterGameMode\n(\nGAMEMODE\n);\n\n    \n}\n\n\n\n\n\nNow your game is ready to be played by users!\n\nBe sure to checkout the other guides in the developer area to learn how to create phases, features and games!", 
            "title": "How to write an addon"
        }, 
        {
            "location": "/developer-area/how-to-write-an-addon/#how-to-write-an-addon", 
            "text": "An addon to VGL is just a normal bukkit plugin with some extra stuff. \nWe will be looking at the 1vs1 game as an example, you can find the full (and updated) code  here \nYour mainclass is pretty straight forward. You want to extend JavaPlugin as usual, but also implement Module (from VGL).\nYou also should mark the class @Singleton and add a @ModuleInfo 1\n2\n3 @Singleton  @ModuleInfo ( name   =   1vs1 ,   authors   =   MiniDigger ,   version   =   1.0.0 )  public   class   OneVsOnePlugin   extends   JavaPlugin   implements   Module   \nThe most important thing is that you add a onLoad that looks like this: 1\n2\n3\n4      @Override \n     public   void   onLoad ()   { \n         ModuleHandler . offerModule ( this );   // always do this first! \n     }   \nThis is the part where your addon hooks into VGL. you want to ignore bukkits onEnable and onDisable and use VGL's enable and disable instead.\nThis will make sure, that you don't do stuff before VGL has initialized your module properly. \nAfter the module has been initalized, you can easly access any part of VGL via guice injections. \nIf you are new to guice, check out this short introduction  here    If your addon offers a new gamemode, you also should register that in your main file. \nAdd a constant called GAMEMODE to hold a reference to your gamemode: 1 public   static   final   GameMode   GAMEMODE   =   new   GameMode ( 1vs1 ,   OneVsOneGame . class );   \nthen register that in your enable method: 1\n2\n3\n4      @Override \n     public   void   enable ()   { \n         gameHandler . registerGameMode ( GAMEMODE ); \n     }   \nNow your game is ready to be played by users! \nBe sure to checkout the other guides in the developer area to learn how to create phases, features and games!", 
            "title": "How to write an addon"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/", 
            "text": "How to write a feature\n\n\nFeatures are small parts of a game that gets added to a phase. Features are the modular core of VGL.\n\nYou should try to create as many features as possible so that game designers can easily remix them into new games.  \n\n\nA feature consits of multile parts:\n\n\n\n\nA @FeatureInfo annotation\n   \n\n\n@Expose'd variables\n   \n\n\nEvent Handlers\n  \n\n\nDependencies\n  \n\n\nstart/stop/tick methods\n    \n\n\n\n\nGeneral\n\n\nA feature extends \nAbstractFeature\n.\n\nYou can access other features (make sure you read about \ndependencies\n first) by calling\n\nYourFeature feature = getPhase().getFeature(YourFeature.class);\n\nYou can find a list of existing features \nhere\n or you can look into \n\nthe features package\n \nVGL has.\n\n\n@FeatureInfo\n\n\nThe feature info adds some metadata to features, that is used to generate documentation. its fairly straight \nforward. Take a look at this example: \n\n@FeatureInfo(name = \nNoBlockBreakFeature\n, author = \nMiniDigger\n, version = \n1.0\n, description = \nSmall feature that blocks block breaking if active\n)\n\n\nExposed Variables\n\n\nIts always a good idea to expose as many vars as possible. Exposed vars will end up in the game definitions, so that\ngame designers can easily adjust them if needed.\n\nYou have to be careful to what you expose, not every type can be easily serialized! (if you are missing a type, there is currently no way to add a custom type adapter, \ncreate an issue on github and we will look into that)\n\nLets look back at our NoBlockBreakFeature:\n\n1\n2\n3\n4\n@Expose\n\n\nprivate\n \nMaterial\n[]\n \nwhitelist\n \n=\n \nnew\n \nMaterial\n[\n0\n];\n\n\n@Expose\n\n\nprivate\n \nMaterial\n[]\n \nblacklist\n \n=\n \nnew\n \nMaterial\n[\n0\n];\n\n\n\n\n\nIt exposes a material black and whitelist. Its important to have a default value so that you don't end up dealing with nulls.\nVGL will make sure that if a game designer modified the values, those fields will be updated.\n\n\nEvent Handlers\n\n\nThere are two types of event handlers in VGL: normal \n@EventHandler\ns and \n@GameEvent\ns. \nThe \n@EventHandler\n annotation works like in every other bukkit plugin, but you need to make sure that you only handle events, that are related \nto the game the feature runs in. You don't want the NoBlockBreakFeature of the SurvivalGames game affect the Bedwars game that is currently running too!\n\nThats where \n@GameEvent\n comes in. It tries to figure out if the event was caused by a player and only forward it to your method, if the player plays in the game the\nfeature is attached too. This doesn't work for every event, you might have to do some checks yourself (like check the world name or something like that).\n\nVGL will print a warning when it couldn't resolve a user.\nGenerally, \n@GameEvent\n works exactly as \n@EventHandler\n:\n\n1\n2\n3\n4\n@GameEvent\n\n\npublic\n \nvoid\n \nonBlockBreak\n(\nBlockBreakEvent\n \nevent\n)\n \n{\n\n\n// your event code\n\n\n}\n\n\n\n\n\nAnother cool feature \n@GameEvent\n provides is the ability to easily get a user object from non-vgl events.\n\nYou just add a second parameter of type \nUser\n to the method:\n\n\n1\n2\n3\n4\n@GameEvent\n\n\npublic\n \nvoid\n \nonBlockBreak\n(\nBlockBreakEvent\n \nevent\n,\n \nUser\n \nuser\n)\n \n{\n\n    \nlog\n.\ninfo\n(\nuser\n.\ngetRawDisplayName\n()\n \n+\n \n broke a block!\n);\n\n\n}\n\n\n\n\n\n\nDependencies\n\n\nSome features require that other features are active. For example there is a Scoreboard feature, that provides scoreboards for all players.\n\nThe map info feature uses that scoreboard and displays some info about the current active map on it.\n\nThat mean, the map info feature depends on both the scoreboard feature and the map feature.\n\nTo implement that, you just have to override the getDependencies (or getSoftDependencies) method:\n\n1\n2\n3\n4\n@Override\n\n\npublic\n \nClass\n[]\n \ngetDependencies\n()\n \n{\n\n    \nreturn\n \nnew\n \nClass\n[]{\nMapFeature\n.\nclass\n,\n \nScoreboardFeature\n.\nclass\n};\n\n\n}\n\n\n\n\n\nVGL then will make sure that the features are present (expect for soft dependencies) and loaded before your feature.\n\nOnce you have that, you can easily access the feature like this:\n\n\n1\n2\n3\n4\nScoreboardFeature\n \nscoreboardFeature\n \n=\n \ngetPhase\n().\ngetFeature\n(\nScoreboardFeature\n.\nclass\n);\n\n\nScoreboard\n \nscoreboard\n \n=\n \nscoreboardFeature\n.\ngetScoreboard\n();\n\n\nscoreboard\n.\ncreateAndAddLine\n(\nChatColor\n.\nYELLOW\n \n+\n \n \n+\n \nChatColor\n.\nBOLD\n \n+\n \nAuthor: \n);\n\n\n.....\n\n\n\n\n\n\nStart/Stop/Tick methods\n\n\nVGL also provides you with some additonal methods you can override: \n\n\n\n\nvoid start(): called when the phase this feature is attached to starts  \n\n\nvoid stop(): called when the phase this feature is attached to stops  \n\n\nvoid tick(): called when the phase this feature is attached to ticks (20 times each second)  \n\n\nvoid init(): called when the feature is added to phase", 
            "title": "How to write a feature"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#how-to-write-a-feature", 
            "text": "Features are small parts of a game that gets added to a phase. Features are the modular core of VGL. \nYou should try to create as many features as possible so that game designers can easily remix them into new games.    A feature consits of multile parts:   A @FeatureInfo annotation      @Expose'd variables      Event Handlers     Dependencies     start/stop/tick methods", 
            "title": "How to write a feature"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#general", 
            "text": "A feature extends  AbstractFeature . \nYou can access other features (make sure you read about  dependencies  first) by calling YourFeature feature = getPhase().getFeature(YourFeature.class); \nYou can find a list of existing features  here  or you can look into  the features package  \nVGL has.", 
            "title": "General"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#featureinfo", 
            "text": "The feature info adds some metadata to features, that is used to generate documentation. its fairly straight \nforward. Take a look at this example:  @FeatureInfo(name =  NoBlockBreakFeature , author =  MiniDigger , version =  1.0 , description =  Small feature that blocks block breaking if active )", 
            "title": "@FeatureInfo"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#exposed-variables", 
            "text": "Its always a good idea to expose as many vars as possible. Exposed vars will end up in the game definitions, so that\ngame designers can easily adjust them if needed. \nYou have to be careful to what you expose, not every type can be easily serialized! (if you are missing a type, there is currently no way to add a custom type adapter, \ncreate an issue on github and we will look into that) \nLets look back at our NoBlockBreakFeature: 1\n2\n3\n4 @Expose  private   Material []   whitelist   =   new   Material [ 0 ];  @Expose  private   Material []   blacklist   =   new   Material [ 0 ];   \nIt exposes a material black and whitelist. Its important to have a default value so that you don't end up dealing with nulls.\nVGL will make sure that if a game designer modified the values, those fields will be updated.", 
            "title": "Exposed Variables"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#event-handlers", 
            "text": "There are two types of event handlers in VGL: normal  @EventHandler s and  @GameEvent s. \nThe  @EventHandler  annotation works like in every other bukkit plugin, but you need to make sure that you only handle events, that are related \nto the game the feature runs in. You don't want the NoBlockBreakFeature of the SurvivalGames game affect the Bedwars game that is currently running too! \nThats where  @GameEvent  comes in. It tries to figure out if the event was caused by a player and only forward it to your method, if the player plays in the game the\nfeature is attached too. This doesn't work for every event, you might have to do some checks yourself (like check the world name or something like that). \nVGL will print a warning when it couldn't resolve a user.\nGenerally,  @GameEvent  works exactly as  @EventHandler : 1\n2\n3\n4 @GameEvent  public   void   onBlockBreak ( BlockBreakEvent   event )   {  // your event code  }   \nAnother cool feature  @GameEvent  provides is the ability to easily get a user object from non-vgl events. \nYou just add a second parameter of type  User  to the method:  1\n2\n3\n4 @GameEvent  public   void   onBlockBreak ( BlockBreakEvent   event ,   User   user )   { \n     log . info ( user . getRawDisplayName ()   +    broke a block! );  }", 
            "title": "Event Handlers"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#dependencies", 
            "text": "Some features require that other features are active. For example there is a Scoreboard feature, that provides scoreboards for all players. \nThe map info feature uses that scoreboard and displays some info about the current active map on it. \nThat mean, the map info feature depends on both the scoreboard feature and the map feature. \nTo implement that, you just have to override the getDependencies (or getSoftDependencies) method: 1\n2\n3\n4 @Override  public   Class []   getDependencies ()   { \n     return   new   Class []{ MapFeature . class ,   ScoreboardFeature . class };  }   \nVGL then will make sure that the features are present (expect for soft dependencies) and loaded before your feature. \nOnce you have that, you can easily access the feature like this:  1\n2\n3\n4 ScoreboardFeature   scoreboardFeature   =   getPhase (). getFeature ( ScoreboardFeature . class );  Scoreboard   scoreboard   =   scoreboardFeature . getScoreboard ();  scoreboard . createAndAddLine ( ChatColor . YELLOW   +     +   ChatColor . BOLD   +   Author:  );  .....", 
            "title": "Dependencies"
        }, 
        {
            "location": "/developer-area/how-to-write-a-feature/#startstoptick-methods", 
            "text": "VGL also provides you with some additonal methods you can override:    void start(): called when the phase this feature is attached to starts    void stop(): called when the phase this feature is attached to stops    void tick(): called when the phase this feature is attached to ticks (20 times each second)    void init(): called when the feature is added to phase", 
            "title": "Start/Stop/Tick methods"
        }, 
        {
            "location": "/developer-area/how-to-write-a-phase/", 
            "text": "How to write a phase\n\n\nA phase is a time period in which certain features are active. \nWriting a phase is pretty straight forward. VGL offers two base phase types: AbstractPhase and TimedPhase. \nTimed phases end after a spefified amount of time, abstract phases need to be ended by a feature. \nThis doesn't mean that features can't end timed phases.\n\nLets take a look at the OneVsOnePhase:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\npublic\n \nclass\n \nOneVsOnePhase\n \nextends\n \nTimedPhase\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninit\n()\n \n{\n\n        \nsetName\n(\nOneVsOnePhase\n);\n\n        \nsetTicks\n(\n2\n \n*\n \n60\n \n*\n \nGameConstants\n.\nTPS\n);\n\n        \nsuper\n.\ninit\n();\n\n        \nsetAllowJoin\n(\nfalse\n);\n\n        \nsetAllowSpectate\n(\ntrue\n);\n\n\n        \nMapFeature\n \nmapFeature\n \n=\n \ngetGame\n().\ncreateFeature\n(\nMapFeature\n.\nclass\n,\n \nthis\n);\n\n        \nmapFeature\n.\nsetShouldUnload\n(\ntrue\n);\n\n        \naddFeature\n(\nmapFeature\n);\n\n\n        \nSpawnFeature\n \nspawnFeature\n \n=\n \ngetGame\n().\ncreateFeature\n(\nSpawnFeature\n.\nclass\n,\n \nthis\n);\n\n        \nspawnFeature\n.\nsetRespawn\n(\nfalse\n);\n\n        \nspawnFeature\n.\nsetInitialSpawn\n(\nfalse\n);\n\n        \naddFeature\n(\nspawnFeature\n);\n\n\n        \nGameModeFeature\n \ngameModeFeature\n \n=\n \ngetGame\n().\ncreateFeature\n(\nGameModeFeature\n.\nclass\n,\n \nthis\n);\n\n        \ngameModeFeature\n.\nsetGameMode\n(\nGameMode\n.\nSURVIVAL\n);\n\n        \naddFeature\n(\ngameModeFeature\n);\n\n\n        \nOneVsOneFeature\n \noneVsOneFeature\n \n=\n \ngetGame\n().\ncreateFeature\n(\nOneVsOneFeature\n.\nclass\n,\n \nthis\n);\n\n        \naddFeature\n(\noneVsOneFeature\n);\n\n\n        \nDuelFeature\n \nduelFeature\n \n=\n \ngetGame\n().\ncreateFeature\n(\nDuelFeature\n.\nclass\n,\n \nthis\n);\n\n        \naddFeature\n(\nduelFeature\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nLooks pretty easy, right? \nLets break it down:\nthe phase extends \nTimedPhase\n, so it will end after a speficied amount of time (ticks).\n\nWe see a init method. that method is called when the phase is added to the game. generally, thats the only \nmethod you need, all game logic should be part of the features.\nAt the top of the init method, we set the name and the time, call the super (IMPORTANT!) and configure if players\ncan join or spectate. \nBelow that, we add a bunch of features. You want to create a feature via the \ncreatFeature\n method \nGame\n offers,\nset some options and then add the feature to the phase. \nCheckout \nHow to write a Feature\n to learn more about features.", 
            "title": "How to write a phase"
        }, 
        {
            "location": "/developer-area/how-to-write-a-phase/#how-to-write-a-phase", 
            "text": "A phase is a time period in which certain features are active. \nWriting a phase is pretty straight forward. VGL offers two base phase types: AbstractPhase and TimedPhase. \nTimed phases end after a spefified amount of time, abstract phases need to be ended by a feature. \nThis doesn't mean that features can't end timed phases. \nLets take a look at the OneVsOnePhase:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 public   class   OneVsOnePhase   extends   TimedPhase   { \n\n     @Override \n     public   void   init ()   { \n         setName ( OneVsOnePhase ); \n         setTicks ( 2   *   60   *   GameConstants . TPS ); \n         super . init (); \n         setAllowJoin ( false ); \n         setAllowSpectate ( true ); \n\n         MapFeature   mapFeature   =   getGame (). createFeature ( MapFeature . class ,   this ); \n         mapFeature . setShouldUnload ( true ); \n         addFeature ( mapFeature ); \n\n         SpawnFeature   spawnFeature   =   getGame (). createFeature ( SpawnFeature . class ,   this ); \n         spawnFeature . setRespawn ( false ); \n         spawnFeature . setInitialSpawn ( false ); \n         addFeature ( spawnFeature ); \n\n         GameModeFeature   gameModeFeature   =   getGame (). createFeature ( GameModeFeature . class ,   this ); \n         gameModeFeature . setGameMode ( GameMode . SURVIVAL ); \n         addFeature ( gameModeFeature ); \n\n         OneVsOneFeature   oneVsOneFeature   =   getGame (). createFeature ( OneVsOneFeature . class ,   this ); \n         addFeature ( oneVsOneFeature ); \n\n         DuelFeature   duelFeature   =   getGame (). createFeature ( DuelFeature . class ,   this ); \n         addFeature ( duelFeature ); \n     }  }   \nLooks pretty easy, right? \nLets break it down:\nthe phase extends  TimedPhase , so it will end after a speficied amount of time (ticks). \nWe see a init method. that method is called when the phase is added to the game. generally, thats the only \nmethod you need, all game logic should be part of the features.\nAt the top of the init method, we set the name and the time, call the super (IMPORTANT!) and configure if players\ncan join or spectate. \nBelow that, we add a bunch of features. You want to create a feature via the  creatFeature  method  Game  offers,\nset some options and then add the feature to the phase. \nCheckout  How to write a Feature  to learn more about features.", 
            "title": "How to write a phase"
        }, 
        {
            "location": "/developer-area/how-to-write-a-game/", 
            "text": "How to write a game\n\n\nA Game is made up from multiple parts. First you want to make sure you have some phases and features you want to use.\nBe sure to check out the other tutorials for that. \nThen you can create a game class. It shoudl extend \nAbstractGame\n and have a \n@GameInfo\n annotation:\n\n1\n2\n@GameInfo\n(\nname\n \n=\n \n1vs1\n,\n \nauthor\n \n=\n \nMiniDigger\n,\n \nversion\n \n=\n \nv1.0\n,\n \ndescription\n \n=\n \n1vs1 Description\n)\n\n\npublic\n \nclass\n \nOneVsOneGame\n \nextends\n \nAbstractGame\n\n\n\n\n\nThen you need to have a constructor. You want to give the super constructor the gamemode constant you made in your addon class\n(If you didn't do that, go back to that step \nhere\n).\n\nYour constructor should look like this:\n\n1\n2\n3\n    \npublic\n \nOneVsOneGame\n()\n \n{\n\n        \nsuper\n(\nOneVsOnePlugin\n.\nGAMEMODE\n);\n\n    \n}\n\n\n\n\n\nThen you have two methods: \ninitGameFromModule\n and \ninitGameFromDefinition.\n \nYour games will be serialized into a game definition by default, so that game designers can edit it easily.\n\nThat mean, that you only want to create phases and features in the \ninitGameFromModule\n method.\nYour initGameFromDefinition method should just be this:\n\n1\n2\n3\n4\n5\n6\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitGameFromDefinition\n(\n@Nonnull\n \nGameDefinition\n \ngameDefinition\n)\n \n{\n\n        \nsuper\n.\ninitGameFromDefinition\n(\ngameDefinition\n);\n\n\n        \nloadMap\n();\n\n    \n}\n\n\n\n\n\n\nloadMap\n will make sure that the lobby map is loaded.\n\nYou define all your phases in the \ninitGameFromModule\n method:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitGameFromModule\n()\n \n{\n\n        \nsetMinPlayers\n(\n2\n);\n\n        \nsetMaxPlayers\n(\n2\n);\n\n\n        \nLobbyWithVotePhase\n \nlobbyWithVotePhase\n \n=\n \ncreatePhase\n(\nLobbyWithVotePhase\n.\nclass\n);\n\n        \nGracePhase\n \ngracePhase\n \n=\n \ncreatePhase\n(\nGracePhase\n.\nclass\n);\n\n        \nOneVsOnePhase\n \nsurvivalGamesPhase\n \n=\n \ncreatePhase\n(\nOneVsOnePhase\n.\nclass\n);\n\n\n        \nlobbyWithVotePhase\n.\nsetNextPhase\n(\ngracePhase\n);\n\n        \ngracePhase\n.\nsetNextPhase\n(\nsurvivalGamesPhase\n);\n\n\n        \nactivePhase\n \n=\n \nlobbyWithVotePhase\n;\n\n\n        \nloadMap\n();\n\n    \n}\n\n\n\n\n\nAs you can see, there are multiple steps:\nFirst, you spefify the min and maxmium amount of players required to play this game.\n\nThen you create all your phases.\n\nAfter that, you make sure the order of phases is right.\n\nIn the end, you specify the first active phase and load the lobby map.\nAnd thats all! Now you can just start a game ingame via \n/game start \ngamemode\n!", 
            "title": "How to write a game"
        }, 
        {
            "location": "/developer-area/how-to-write-a-game/#how-to-write-a-game", 
            "text": "A Game is made up from multiple parts. First you want to make sure you have some phases and features you want to use.\nBe sure to check out the other tutorials for that. \nThen you can create a game class. It shoudl extend  AbstractGame  and have a  @GameInfo  annotation: 1\n2 @GameInfo ( name   =   1vs1 ,   author   =   MiniDigger ,   version   =   v1.0 ,   description   =   1vs1 Description )  public   class   OneVsOneGame   extends   AbstractGame   \nThen you need to have a constructor. You want to give the super constructor the gamemode constant you made in your addon class\n(If you didn't do that, go back to that step  here ). \nYour constructor should look like this: 1\n2\n3      public   OneVsOneGame ()   { \n         super ( OneVsOnePlugin . GAMEMODE ); \n     }   \nThen you have two methods:  initGameFromModule  and  initGameFromDefinition.  \nYour games will be serialized into a game definition by default, so that game designers can edit it easily. \nThat mean, that you only want to create phases and features in the  initGameFromModule  method.\nYour initGameFromDefinition method should just be this: 1\n2\n3\n4\n5\n6      @Override \n     public   void   initGameFromDefinition ( @Nonnull   GameDefinition   gameDefinition )   { \n         super . initGameFromDefinition ( gameDefinition ); \n\n         loadMap (); \n     }    loadMap  will make sure that the lobby map is loaded. \nYou define all your phases in the  initGameFromModule  method:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16      @Override \n     public   void   initGameFromModule ()   { \n         setMinPlayers ( 2 ); \n         setMaxPlayers ( 2 ); \n\n         LobbyWithVotePhase   lobbyWithVotePhase   =   createPhase ( LobbyWithVotePhase . class ); \n         GracePhase   gracePhase   =   createPhase ( GracePhase . class ); \n         OneVsOnePhase   survivalGamesPhase   =   createPhase ( OneVsOnePhase . class ); \n\n         lobbyWithVotePhase . setNextPhase ( gracePhase ); \n         gracePhase . setNextPhase ( survivalGamesPhase ); \n\n         activePhase   =   lobbyWithVotePhase ; \n\n         loadMap (); \n     }   \nAs you can see, there are multiple steps:\nFirst, you spefify the min and maxmium amount of players required to play this game. \nThen you create all your phases. \nAfter that, you make sure the order of phases is right. \nIn the end, you specify the first active phase and load the lobby map.\nAnd thats all! Now you can just start a game ingame via  /game start  gamemode !", 
            "title": "How to write a game"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/", 
            "text": "Introduction to guice\n\n\nVGL heavily uses guice. This short page aims to give you a small overview of what you can do with guice.\nFor more details we suggest you to read googles excelent wiki \nhttps://github.com/google/guice/wiki\n\n\nBasic injections\n\n\nGuice is an dependency injection framework. That means, you can get a reference to any class handled by guice\nvia a simple \n@Inject\n annotation on a field.\n\nFor example, you might want to start a bukkit scheduler in your OneVsOne game.\nAll you have to do is this:\n\n1\n2\n3\n4\n5\n6\n// some field\n\n\n@Inject\n\n\nprivate\n \nOneVsOnePlugin\n \nplugin\n;\n\n\n\n// some method\n\n\nBukkit\n.\ngetScheduler\n().\nrunTask\n(\nplugin\n,\n \ntask\n);\n\n\n\n\n\nGuice will take care of getting the right instance of OneVsOnePlugin.  \n\n\nTo make this all work, you have to add an annotation to the classes you only ever want one instance of.\n\nFor example, you never want more then 1 instance of your plugin class, since else bukkit would complain.\n\nTo tell guice that, you need to add a \n@Singleton\n annotation to the class. \n\n\nGenerally you can inject almost every class. Want to do something with users? \n@Inject UserHandler userHandler;\n.\nNeed to get the games of a player? \n@Inject GameHandler gameHandler\n. \n\n\nNamed injections\n\n\nGuice also has the option to have multiple instances of the same type. To specify which instance you want, you use the\n\n@Named(\nname\n)\n annotation.\n\nVGL defined a set of named annotations, you can see them here:\n\n\nhttps://github.com/VoxelGamesLib/VoxelGamesLibv2/blob/master/VoxelGamesLib/src/main/java/com/voxelgameslib/voxelgameslib/VoxelGamesLibModule.java#L68-L93\n\nFor example, the \nKitHandler\n gets a reference to the kits folder like this:\n\n1\n2\n3\n    \n@Inject\n\n    \n@Named\n(\nKitsFolder\n)\n\n    \nprivate\n \nFile\n \nkitsDir\n;\n\n\n\n\n\n\nInject Gson\n\n\nVGL also setup guice to provide two guice instances. Those are equiped with the custom type adapters for stuff like phases for features.\n\nThere is the normal \n@Inject Gson gson\n which will be injected with a json instance that has pretty prinitng and excludes every field that isn't \nmarked with \n@Exposed\n. The other one will include all fields, you can get it with \n\n1\n2\n3\n@Inject\n\n\n@Named\n(\nIgnoreExposedBS\n)\n\n\nprivate\n \nGson\n \ngson\n;\n\n\n\n\n\nThis instance has pretty prining enabled too. Need one without pretty printing? let us know!\n\n\nCustom guice settings\n\n\nthis is currently not implemented. If you need this, be sure to bump \nhttps://github.com/VoxelGamesLib/VoxelGamesLibv2/issues/71\n to let us know!", 
            "title": "Introduction to Guice"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/#introduction-to-guice", 
            "text": "VGL heavily uses guice. This short page aims to give you a small overview of what you can do with guice.\nFor more details we suggest you to read googles excelent wiki  https://github.com/google/guice/wiki", 
            "title": "Introduction to guice"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/#basic-injections", 
            "text": "Guice is an dependency injection framework. That means, you can get a reference to any class handled by guice\nvia a simple  @Inject  annotation on a field. \nFor example, you might want to start a bukkit scheduler in your OneVsOne game.\nAll you have to do is this: 1\n2\n3\n4\n5\n6 // some field  @Inject  private   OneVsOnePlugin   plugin ;  // some method  Bukkit . getScheduler (). runTask ( plugin ,   task );   \nGuice will take care of getting the right instance of OneVsOnePlugin.    To make this all work, you have to add an annotation to the classes you only ever want one instance of. \nFor example, you never want more then 1 instance of your plugin class, since else bukkit would complain. \nTo tell guice that, you need to add a  @Singleton  annotation to the class.   Generally you can inject almost every class. Want to do something with users?  @Inject UserHandler userHandler; .\nNeed to get the games of a player?  @Inject GameHandler gameHandler .", 
            "title": "Basic injections"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/#named-injections", 
            "text": "Guice also has the option to have multiple instances of the same type. To specify which instance you want, you use the @Named( name )  annotation. \nVGL defined a set of named annotations, you can see them here:  https://github.com/VoxelGamesLib/VoxelGamesLibv2/blob/master/VoxelGamesLib/src/main/java/com/voxelgameslib/voxelgameslib/VoxelGamesLibModule.java#L68-L93 \nFor example, the  KitHandler  gets a reference to the kits folder like this: 1\n2\n3      @Inject \n     @Named ( KitsFolder ) \n     private   File   kitsDir ;", 
            "title": "Named injections"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/#inject-gson", 
            "text": "VGL also setup guice to provide two guice instances. Those are equiped with the custom type adapters for stuff like phases for features. \nThere is the normal  @Inject Gson gson  which will be injected with a json instance that has pretty prinitng and excludes every field that isn't \nmarked with  @Exposed . The other one will include all fields, you can get it with  1\n2\n3 @Inject  @Named ( IgnoreExposedBS )  private   Gson   gson ;   \nThis instance has pretty prining enabled too. Need one without pretty printing? let us know!", 
            "title": "Inject Gson"
        }, 
        {
            "location": "/developer-area/introduction-to-guice/#custom-guice-settings", 
            "text": "this is currently not implemented. If you need this, be sure to bump  https://github.com/VoxelGamesLib/VoxelGamesLibv2/issues/71  to let us know!", 
            "title": "Custom guice settings"
        }, 
        {
            "location": "/developer-area/apis/scoreboard/", 
            "text": "", 
            "title": "Scoreboard API"
        }, 
        {
            "location": "/developer-area/apis/kit/", 
            "text": "", 
            "title": "Kit API"
        }, 
        {
            "location": "/developer-area/apis/sign/", 
            "text": "Sign API\n\n\nThere are two ways VGL allows you to work with signs: Sign Buttons or Sign Placeholders\n\n\nSign Buttons\n\n\nSigns buttons are signs with special '[keys]' which execute some code when being clicked by players.\n\nTo define a button, you need to get the instance of the SignButtons class. To do this you can just @Inject it via guice.\n\nThat class offers you a method registerButton which takes a key and a lambda:\n\n1\nsignButtons\n.\nregisterButton\n(\nhello\n,\n \n(\nuser\n,\n \nblock\n)\n \n-\n \nuser\n.\nsendMessage\n(\nTextComponent\n.\nof\n(\nWOW\n)));\n\n\n\n\n\n\nSign Placeholders\n\n\nSign Placeholders allow you to dynamically change text on a sign and show individual text for players.\n\nThere are two types of placeholders, simple, that only replace the key, and full, which replace the whole sign.\n\nTo register placeholders, you need to get the instance of the SignPlaceholders class. To do this you can just @Inject it via guice. \nThat class offers you a method registerPlaceholder which takes a key and a lmabda:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n       \nregisterPlaceholder\n(\ntime\n,\n \n(\nSimpleSignPlaceHolder\n)\n\n            \n(\nuser\n,\n \nlocation\n,\n \nrawLines\n,\n \nlines\n,\n \nkey\n)\n \n-\n\n                \nTextComponent\n.\nof\n(\nDateTimeFormatter\n.\nISO_TIME\n.\nformat\n(\nLocalTime\n.\nnow\n())));\n\n\n       \nregisterPlaceholder\n(\ngreeting\n,\n \n(\nFullSignPlaceHolder\n)\n\n            \n(\nuser\n,\n \nloc\n,\n \nrawLines\n,\n \nlines\n,\n \nkey\n)\n \n-\n \nnew\n \nComponent\n[]{\n\n                \nTextComponent\n.\nof\n(\nHey there\n),\n\n                \nuser\n.\ngetDisplayName\n(),\n\n                \nTextComponent\n.\nof\n(\n),\n\n                \nTextComponent\n.\nof\n(\n)\n\n            \n});\n\n\n       \nregisterPlaceholder\n(\nname\n,\n \n(\nSimpleSignPlaceHolder\n)\n\n            \n(\nuser\n,\n \nloc\n,\n \nrawLines\n,\n \nlines\n,\n \nkey\n)\n \n-\n \n                \nuser\n.\ngetDisplayName\n());\n\n\n\n\n\n\nAn example sign for time could look like this:\n\"Hello [name].\"\n\n\"The time is\"\n\n\"[time]\"\n\nwhich would be replaced to:\n\"Hello MiniDigger\"\n\n\"The time is\"\n\n\"16:11:25.154\"  \n\n\nSigns update every second or when clicked by a player (with a 1 second cooldown).", 
            "title": "Sign API"
        }, 
        {
            "location": "/developer-area/apis/sign/#sign-api", 
            "text": "There are two ways VGL allows you to work with signs: Sign Buttons or Sign Placeholders", 
            "title": "Sign API"
        }, 
        {
            "location": "/developer-area/apis/sign/#sign-buttons", 
            "text": "Signs buttons are signs with special '[keys]' which execute some code when being clicked by players. \nTo define a button, you need to get the instance of the SignButtons class. To do this you can just @Inject it via guice. \nThat class offers you a method registerButton which takes a key and a lambda: 1 signButtons . registerButton ( hello ,   ( user ,   block )   -   user . sendMessage ( TextComponent . of ( WOW )));", 
            "title": "Sign Buttons"
        }, 
        {
            "location": "/developer-area/apis/sign/#sign-placeholders", 
            "text": "Sign Placeholders allow you to dynamically change text on a sign and show individual text for players. \nThere are two types of placeholders, simple, that only replace the key, and full, which replace the whole sign. \nTo register placeholders, you need to get the instance of the SignPlaceholders class. To do this you can just @Inject it via guice. \nThat class offers you a method registerPlaceholder which takes a key and a lmabda:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15         registerPlaceholder ( time ,   ( SimpleSignPlaceHolder ) \n             ( user ,   location ,   rawLines ,   lines ,   key )   - \n                 TextComponent . of ( DateTimeFormatter . ISO_TIME . format ( LocalTime . now ()))); \n\n        registerPlaceholder ( greeting ,   ( FullSignPlaceHolder ) \n             ( user ,   loc ,   rawLines ,   lines ,   key )   -   new   Component []{ \n                 TextComponent . of ( Hey there ), \n                 user . getDisplayName (), \n                 TextComponent . of ( ), \n                 TextComponent . of ( ) \n             }); \n\n        registerPlaceholder ( name ,   ( SimpleSignPlaceHolder ) \n             ( user ,   loc ,   rawLines ,   lines ,   key )   -  \n                 user . getDisplayName ());    An example sign for time could look like this:\n\"Hello [name].\" \n\"The time is\" \n\"[time]\" \nwhich would be replaced to:\n\"Hello MiniDigger\" \n\"The time is\" \n\"16:11:25.154\"    Signs update every second or when clicked by a player (with a 1 second cooldown).", 
            "title": "Sign Placeholders"
        }, 
        {
            "location": "/developer-area/apis/elo/", 
            "text": "Elo\n\n\nVGL uses an implementation of the TrueSkill algorithm to calculate a Elo score for players, based on their wins and looses and the scores of their opponents.\n\nThe framework does this automatically. If you use the TeamFeature, VGL will make sure that everybody on the winning team sees an increase in their rating, while the other teams looses points.\n\nFor normal or duel based games, VGL will do the same: The winner will see an increase while the rest will some Elo.  \n\n\nIf you want to learn more about how exactly the algorithm works, I suggest you to read this excellent blog post, which helped me understand the topic: \nhttp://www.moserware.com/2010/03/computing-your-skill.html\n\nI will not explain it in full detail here, but give a slight overview:\n\nBasically, the higher the difference between your skill/rating/elo and the skill/rating/elo of your openent(s), the more elo the lower rated player can gain and the higher player can loose. if you win against a higher skilled player, you will see an higher increase in elo than winning against a lower skilled player. Additionally, trueskill also has a sort of stability factor, to work against fast changes. At the beginning, you will see fast changes in your rating, but the more games you play, the more will your elo stabilize in some area. \n\n\nThe api\n\n\nYou can get access to the rating of a User via User#getRating(GameMode). The value you will most likely be interrested in is the mean, this is what we would call the elo score. \nThats really all you need, since VGL handles everything for you.", 
            "title": "Elo API"
        }, 
        {
            "location": "/developer-area/apis/elo/#elo", 
            "text": "VGL uses an implementation of the TrueSkill algorithm to calculate a Elo score for players, based on their wins and looses and the scores of their opponents. \nThe framework does this automatically. If you use the TeamFeature, VGL will make sure that everybody on the winning team sees an increase in their rating, while the other teams looses points. \nFor normal or duel based games, VGL will do the same: The winner will see an increase while the rest will some Elo.    If you want to learn more about how exactly the algorithm works, I suggest you to read this excellent blog post, which helped me understand the topic:  http://www.moserware.com/2010/03/computing-your-skill.html \nI will not explain it in full detail here, but give a slight overview: \nBasically, the higher the difference between your skill/rating/elo and the skill/rating/elo of your openent(s), the more elo the lower rated player can gain and the higher player can loose. if you win against a higher skilled player, you will see an higher increase in elo than winning against a lower skilled player. Additionally, trueskill also has a sort of stability factor, to work against fast changes. At the beginning, you will see fast changes in your rating, but the more games you play, the more will your elo stabilize in some area.", 
            "title": "Elo"
        }, 
        {
            "location": "/developer-area/apis/elo/#the-api", 
            "text": "You can get access to the rating of a User via User#getRating(GameMode). The value you will most likely be interrested in is the mean, this is what we would call the elo score. \nThats really all you need, since VGL handles everything for you.", 
            "title": "The api"
        }, 
        {
            "location": "/developer-area/apis/command/", 
            "text": "Command API\n\n\nVGL does not longer uses a custom command api, it uses \nACF by aikar\n\n\nFeatures can provide commands by implementing \nFeatureCommandImplementor\n (I hate that name as much as you do) \nand defining them in an inner class that extends \nAbstractFeatureCommand\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n    \npublic\n \nclass\n \nVoteFeature\n \nextends\n \nAbstractFeature\n \nimplements\n \nFeatureCommandImplementor\n{\n\n\n    \n.....\n\n\n    \n@Override\n\n    \npublic\n \nAbstractFeatureCommand\n \ngetCommandClass\n()\n \n{\n\n        \nreturn\n \nnew\n \nVoteFeatureCommand\n();\n\n    \n}\n\n\n    \n@Singleton\n\n    \nclass\n \nVoteFeatureCommand\n \nextends\n \nAbstractFeatureCommand\n \n{\n\n\n        \n@CommandAlias\n(\nvote\n)\n\n        \n@CommandPermission\n(\n%user\n)\n\n        \n@Syntax\n(\n[map] - the map to vote for\n)\n\n        \npublic\n \nvoid\n \nvote\n(\nUser\n \nsender\n,\n \n@Optional\n \nInteger\n \nmap\n)\n \n{\n\n            \nif\n \n(\nmap\n \n==\n \nnull\n)\n \n{\n\n                \nsendVoteMessage\n(\nsender\n);\n\n            \n}\n \nelse\n \n{\n\n                \nconfirmVote\n(\nsender\n,\n \nmap\n);\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nOther classes can register commands by injecting a \nBukkitCommandManager\n via and registering the command using that.\n\n\nFor a general documentation on how to write command with ACF, please see the \nACF wiki", 
            "title": "Command API"
        }, 
        {
            "location": "/developer-area/apis/command/#command-api", 
            "text": "VGL does not longer uses a custom command api, it uses  ACF by aikar  Features can provide commands by implementing  FeatureCommandImplementor  (I hate that name as much as you do) \nand defining them in an inner class that extends  AbstractFeatureCommand :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24      public   class   VoteFeature   extends   AbstractFeature   implements   FeatureCommandImplementor { \n\n     ..... \n\n     @Override \n     public   AbstractFeatureCommand   getCommandClass ()   { \n         return   new   VoteFeatureCommand (); \n     } \n\n     @Singleton \n     class   VoteFeatureCommand   extends   AbstractFeatureCommand   { \n\n         @CommandAlias ( vote ) \n         @CommandPermission ( %user ) \n         @Syntax ( [map] - the map to vote for ) \n         public   void   vote ( User   sender ,   @Optional   Integer   map )   { \n             if   ( map   ==   null )   { \n                 sendVoteMessage ( sender ); \n             }   else   { \n                 confirmVote ( sender ,   map ); \n             } \n         } \n     }  }    Other classes can register commands by injecting a  BukkitCommandManager  via and registering the command using that.  For a general documentation on how to write command with ACF, please see the  ACF wiki", 
            "title": "Command API"
        }, 
        {
            "location": "/developer-area/apis/ability/", 
            "text": "", 
            "title": "Ability API"
        }, 
        {
            "location": "/developer-area/apis/i18n/", 
            "text": "i18n API\n\n\nVGL was made with i18n in mind. Every user facing message is configurable. Your games should do that too.\n\nTo do that, VGL internally uses a nice api and provides ways where you can inject your own keys to be translated.\n\n\nThe lang key class\n\n\nFirst you will need a lang key class. VGL has a class named LangKey for internal usage, your class will look similar to it.\nUse this as a template:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\npublic\n \nenum\n \nMyLangKey\n \nimplements\n \nExternalTranslatable\n \n{\n\n\n    \nDUMMY\n(\ndummy\n),\n// we will need this once later\n\n\n    \nSOME_MSG\n(\n{aqua}This is a {yellow}{adjective}{aqua} API\n,\n \nadjective\n);\n\n\n    \n@Nonnull\n\n    \nprivate\n \nfinal\n \nString\n \ndefaultValue\n;\n\n\n    \n@Nonnull\n\n    \nprivate\n \nfinal\n \nString\n[]\n \nargs\n;\n\n\n    \nprivate\n \nstatic\n \nUUID\n \nuuid\n \n=\n \nUUID\n.\nrandomUUID\n();\n\n\n    \nHubLangKey\n(\n@Nonnull\n \nString\n \ndefaultValue\n,\n \n@Nonnull\n \nString\n...\n \nargs\n)\n \n{\n\n        \nthis\n.\ndefaultValue\n \n=\n \ndefaultValue\n;\n\n        \nthis\n.\nargs\n \n=\n \nargs\n;\n\n    \n}\n\n\n    \n@Override\n\n    \n@Nonnull\n\n    \npublic\n \nString\n \ngetDefaultValue\n()\n \n{\n\n        \nreturn\n \ndefaultValue\n;\n\n    \n}\n\n\n    \n@Override\n\n    \n@Nonnull\n\n    \npublic\n \nString\n[]\n \ngetArgs\n()\n \n{\n\n        \nreturn\n \nargs\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nUUID\n \ngetUuid\n()\n \n{\n\n        \nreturn\n \nuuid\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nTranslatable\n[]\n \ngetValues\n()\n \n{\n\n        \nreturn\n \nvalues\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nAs you can see, its an enum in which you define keys, default values and the args the keys use. To learn more\nabout how the lang format works, check out the guide here //TODO add link to guide\n\n\nRegistering the new lang key class\n\n\nVGL will need to know about the new keys and we need files where your users can change the messages. LangHandler takes \ncare of all that. Just @Inject a LangHander into your plugin class and call this in your enable method:\n\n1\n \nlangHandler\n.\nregisterExternalLangProvider\n(\nMyLangKey\n.\nDUMMY\n,\n \nnew\n \nFile\n(\ngetDataFolder\n(),\n \nlang\n));\n\n\n\n\n\nThis will create a folder with some lang files for the default values.\n\n\nUsing the i18n api to translate messages\n\n\nThere are many ways you can send a message using the api. You can to take a look at the Lang class for all options.\nMost of the time you want to use Lang#msg like this:\n\n1\nLang\n.\nmsg\n(\nuser\n,\nMyLangKey\n.\nSOME_MSG\n,\ncool\n);\n\n\n\n\n\nThat will send \nThis is a cool API\n to the player, translated into his default lang.\n\nThe order of the arguments is the same as the order you specified in the enum.", 
            "title": "i18n API"
        }, 
        {
            "location": "/developer-area/apis/i18n/#i18n-api", 
            "text": "VGL was made with i18n in mind. Every user facing message is configurable. Your games should do that too. \nTo do that, VGL internally uses a nice api and provides ways where you can inject your own keys to be translated.", 
            "title": "i18n API"
        }, 
        {
            "location": "/developer-area/apis/i18n/#the-lang-key-class", 
            "text": "First you will need a lang key class. VGL has a class named LangKey for internal usage, your class will look similar to it.\nUse this as a template:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41 public   enum   MyLangKey   implements   ExternalTranslatable   { \n\n     DUMMY ( dummy ), // we will need this once later \n\n     SOME_MSG ( {aqua}This is a {yellow}{adjective}{aqua} API ,   adjective ); \n\n     @Nonnull \n     private   final   String   defaultValue ; \n\n     @Nonnull \n     private   final   String []   args ; \n\n     private   static   UUID   uuid   =   UUID . randomUUID (); \n\n     HubLangKey ( @Nonnull   String   defaultValue ,   @Nonnull   String ...   args )   { \n         this . defaultValue   =   defaultValue ; \n         this . args   =   args ; \n     } \n\n     @Override \n     @Nonnull \n     public   String   getDefaultValue ()   { \n         return   defaultValue ; \n     } \n\n     @Override \n     @Nonnull \n     public   String []   getArgs ()   { \n         return   args ; \n     } \n\n     @Override \n     public   UUID   getUuid ()   { \n         return   uuid ; \n     } \n\n     @Override \n     public   Translatable []   getValues ()   { \n         return   values (); \n     }  }   \nAs you can see, its an enum in which you define keys, default values and the args the keys use. To learn more\nabout how the lang format works, check out the guide here //TODO add link to guide", 
            "title": "The lang key class"
        }, 
        {
            "location": "/developer-area/apis/i18n/#registering-the-new-lang-key-class", 
            "text": "VGL will need to know about the new keys and we need files where your users can change the messages. LangHandler takes \ncare of all that. Just @Inject a LangHander into your plugin class and call this in your enable method: 1   langHandler . registerExternalLangProvider ( MyLangKey . DUMMY ,   new   File ( getDataFolder (),   lang ));   \nThis will create a folder with some lang files for the default values.", 
            "title": "Registering the new lang key class"
        }, 
        {
            "location": "/developer-area/apis/i18n/#using-the-i18n-api-to-translate-messages", 
            "text": "There are many ways you can send a message using the api. You can to take a look at the Lang class for all options.\nMost of the time you want to use Lang#msg like this: 1 Lang . msg ( user , MyLangKey . SOME_MSG , cool );   \nThat will send  This is a cool API  to the player, translated into his default lang. \nThe order of the arguments is the same as the order you specified in the enum.", 
            "title": "Using the i18n api to translate messages"
        }, 
        {
            "location": "/developer-area/apis/stats/", 
            "text": "Stats API\n\n\nVGL allows you to track all kind of stats for your players. This page will explain you how your addon and provide new stat types and how to use the api in general.\n\n\nDefining new stat types\n\n\nStatTypes are defined via an enum, that has to look somewhat like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\npublic\n \nenum\n \nOneVsOneStats\n \nimplements\n \nTrackable\n \n{\n\n\n    \nKILLS\n(\nOneVsOneLangKey\n.\nSTAT_KILLS_NAME\n,\n \nOneVsOneLangKey\n.\nSTAT_KILLS_TEXT\n,\n \ntrue\n,\n \nStatFormatter\n.\nINT\n),\n\n    \nGAMES\n(\nOneVsOneLangKey\n.\nSTAT_GAMES_NAME\n,\n \nOneVsOneLangKey\n.\nSTAT_GAMES_TEXT\n,\n \ntrue\n,\n \nStatFormatter\n.\nINT\n);\n\n\n    \nprivate\n \nStat\n \nstat\n;\n\n    \nprivate\n \nTranslatable\n \ndisplayName\n;\n\n    \nprivate\n \nTranslatable\n \ntext\n;\n\n    \nprivate\n \nboolean\n \nannounce\n;\n\n    \nprivate\n \nStatFormatter\n \nstatFormatter\n;\n\n\n    \nOneVsOneStats\n(\nTranslatable\n \ndisplayName\n,\n \nTranslatable\n \ntext\n,\n \nboolean\n \nannounce\n)\n \n{\n\n        \nthis\n(\ndisplayName\n,\n \ntext\n,\n \nannounce\n,\n \nStatFormatter\n.\nDOUBLE\n);\n\n    \n}\n\n\n    \nOneVsOneStats\n(\nTranslatable\n \ndisplayName\n,\n \nTranslatable\n \ntext\n,\n \nboolean\n \nannounce\n,\n \nStatFormatter\n \nstatFormatter\n)\n \n{\n\n        \nthis\n.\ndisplayName\n \n=\n \ndisplayName\n;\n\n        \nthis\n.\ntext\n \n=\n \ntext\n;\n\n        \nthis\n.\nannounce\n \n=\n \nannounce\n;\n\n        \nthis\n.\nstatFormatter\n \n=\n \nstatFormatter\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nsetStat\n(\nStat\n \nstat\n)\n \n{\n\n        \nthis\n.\nstat\n \n=\n \nstat\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nStat\n \ngetStat\n()\n \n{\n\n        \nreturn\n \nstat\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nStatInstance\n \ngetInstance\n(\nUser\n \nuser\n)\n \n{\n\n        \nreturn\n \nstat\n.\ngetInstance\n(\nuser\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nStatInstance\n \ngetInstance\n(\nUUID\n \nid\n)\n \n{\n\n        \nreturn\n \nstat\n.\ngetInstance\n(\nid\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nStatInstance\n \ngetNewInstance\n(\nUUID\n \nuuid\n)\n \n{\n\n        \nreturn\n \nstat\n.\ngetNewInstance\n(\nuuid\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nTranslatable\n \ngetDisplayName\n()\n \n{\n\n        \nreturn\n \ndisplayName\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nTranslatable\n \ngetText\n()\n \n{\n\n        \nreturn\n \ntext\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nStatFormatter\n \ngetStatFormatter\n()\n \n{\n\n        \nreturn\n \nstatFormatter\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nString\n \nformatLong\n(\ndouble\n \nval\n,\n \nLocale\n \nlocale\n)\n \n{\n\n        \nreturn\n \nLang\n.\nstring\n(\ntext\n,\n \nlocale\n,\n \nstatFormatter\n.\nformat\n(\nval\n));\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nString\n \nformatShort\n(\ndouble\n \nval\n)\n \n{\n\n        \nreturn\n \nstatFormatter\n.\nformat\n(\nval\n);\n\n    \n}\n\n\n    \n// workaround for not having access to the user handler\n\n    \n@Override\n\n    \npublic\n \nUser\n \ngetUser\n(\nUUID\n \nid\n)\n \n{\n\n        \nreturn\n \nstat\n.\ngetUser\n(\nid\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nTrackable\n[]\n \ngetValues\n()\n \n{\n\n        \nreturn\n \nvalues\n();\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nshouldAnnounce\n()\n \n{\n\n        \nreturn\n \nannounce\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nsetAnnounce\n(\nboolean\n \nannounce\n)\n \n{\n\n        \nthis\n.\nannounce\n \n=\n \nannounce\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nString\n \ngetPrefix\n()\n \n{\n\n        \nreturn\n \nONEVSONE\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nMost of the stuff you can just copy paste (blame java for not having enum inheritance), you want to change the prefix (last line) tho. \n\nThis will be used as an identifier of your addon for stats, limilar how minecraft keys work for items in minecraft. if you have a stats type with the prefix ONEPLUSONE and an enum constant named KILLS, you can use the stat type in commands using ONEPLUSONE:KILLS.\n\nThe other thing you will want to change are obvisouly the enum constants. They need i18n names, a boolean stating if changes should be announced to the player, and optionally a formatter.\n\nCheck the \nStatsFormatter\n class to take a look at default formatters or implement your own one. You can fine the class \nhere\n.\n\n\nRegistering external trackables (aka stat types)\n\n\nNow you need to register that class. To do that, @Inject a StatHandler class into your module and in your enable method, register it with some random enum instance: \n\n1\nstatsHandler\n.\nregisterTrackable\n(\nOneVsOneStats\n.\nKILLS\n);\n\n\n\n\n\n\nUsing the stats api\n\n\nUsing the stats api is easy:\n\n1\n2\n3\n4\n5\n6\n7\n8\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\nincrement\n();\n \n// increment ONEPLUSONE:GAMES by 1\n\n\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\nincrement\n(\n2\n);\n \n// increment ONEPLUSONE:GAMES by 2\n\n\n\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\ndecrement\n();\n \n// decrement ONEPLUSONE:GAMES by 1\n\n\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\ndecrement\n(\n2\n);\n \n// decrement ONEPLUSONE:GAMES by 2\n\n\n\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\ngetVal\n();\n \n// return the val of ONEPLUSONE:GAMES\n\n\nOneVsOneStats\n.\nGAMES\n.\ngetInstance\n(\nuser\n).\nsetVal\n(\n42\n);\n \n// set ONEPLUSONE:GAMES to 42\n\n\n\n\n\nBe sure to also check out the \njavadocs for statsinstance\n.", 
            "title": "Stats API"
        }, 
        {
            "location": "/developer-area/apis/stats/#stats-api", 
            "text": "VGL allows you to track all kind of stats for your players. This page will explain you how your addon and provide new stat types and how to use the api in general.", 
            "title": "Stats API"
        }, 
        {
            "location": "/developer-area/apis/stats/#defining-new-stat-types", 
            "text": "StatTypes are defined via an enum, that has to look somewhat like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98 public   enum   OneVsOneStats   implements   Trackable   { \n\n     KILLS ( OneVsOneLangKey . STAT_KILLS_NAME ,   OneVsOneLangKey . STAT_KILLS_TEXT ,   true ,   StatFormatter . INT ), \n     GAMES ( OneVsOneLangKey . STAT_GAMES_NAME ,   OneVsOneLangKey . STAT_GAMES_TEXT ,   true ,   StatFormatter . INT ); \n\n     private   Stat   stat ; \n     private   Translatable   displayName ; \n     private   Translatable   text ; \n     private   boolean   announce ; \n     private   StatFormatter   statFormatter ; \n\n     OneVsOneStats ( Translatable   displayName ,   Translatable   text ,   boolean   announce )   { \n         this ( displayName ,   text ,   announce ,   StatFormatter . DOUBLE ); \n     } \n\n     OneVsOneStats ( Translatable   displayName ,   Translatable   text ,   boolean   announce ,   StatFormatter   statFormatter )   { \n         this . displayName   =   displayName ; \n         this . text   =   text ; \n         this . announce   =   announce ; \n         this . statFormatter   =   statFormatter ; \n     } \n\n     @Override \n     public   void   setStat ( Stat   stat )   { \n         this . stat   =   stat ; \n     } \n\n     @Override \n     public   Stat   getStat ()   { \n         return   stat ; \n     } \n\n     @Override \n     public   StatInstance   getInstance ( User   user )   { \n         return   stat . getInstance ( user ); \n     } \n\n     @Override \n     public   StatInstance   getInstance ( UUID   id )   { \n         return   stat . getInstance ( id ); \n     } \n\n     @Override \n     public   StatInstance   getNewInstance ( UUID   uuid )   { \n         return   stat . getNewInstance ( uuid ); \n     } \n\n     @Override \n     public   Translatable   getDisplayName ()   { \n         return   displayName ; \n     } \n\n     @Override \n     public   Translatable   getText ()   { \n         return   text ; \n     } \n\n     @Override \n     public   StatFormatter   getStatFormatter ()   { \n         return   statFormatter ; \n     } \n\n     @Override \n     public   String   formatLong ( double   val ,   Locale   locale )   { \n         return   Lang . string ( text ,   locale ,   statFormatter . format ( val )); \n     } \n\n     @Override \n     public   String   formatShort ( double   val )   { \n         return   statFormatter . format ( val ); \n     } \n\n     // workaround for not having access to the user handler \n     @Override \n     public   User   getUser ( UUID   id )   { \n         return   stat . getUser ( id ); \n     } \n\n     @Override \n     public   Trackable []   getValues ()   { \n         return   values (); \n     } \n\n     @Override \n     public   boolean   shouldAnnounce ()   { \n         return   announce ; \n     } \n\n     @Override \n     public   void   setAnnounce ( boolean   announce )   { \n         this . announce   =   announce ; \n     } \n\n     @Override \n     public   String   getPrefix ()   { \n         return   ONEVSONE ; \n     }  }    Most of the stuff you can just copy paste (blame java for not having enum inheritance), you want to change the prefix (last line) tho.  \nThis will be used as an identifier of your addon for stats, limilar how minecraft keys work for items in minecraft. if you have a stats type with the prefix ONEPLUSONE and an enum constant named KILLS, you can use the stat type in commands using ONEPLUSONE:KILLS. \nThe other thing you will want to change are obvisouly the enum constants. They need i18n names, a boolean stating if changes should be announced to the player, and optionally a formatter. \nCheck the  StatsFormatter  class to take a look at default formatters or implement your own one. You can fine the class  here .", 
            "title": "Defining new stat types"
        }, 
        {
            "location": "/developer-area/apis/stats/#registering-external-trackables-aka-stat-types", 
            "text": "Now you need to register that class. To do that, @Inject a StatHandler class into your module and in your enable method, register it with some random enum instance:  1 statsHandler . registerTrackable ( OneVsOneStats . KILLS );", 
            "title": "Registering external trackables (aka stat types)"
        }, 
        {
            "location": "/developer-area/apis/stats/#using-the-stats-api", 
            "text": "Using the stats api is easy: 1\n2\n3\n4\n5\n6\n7\n8 OneVsOneStats . GAMES . getInstance ( user ). increment ();   // increment ONEPLUSONE:GAMES by 1  OneVsOneStats . GAMES . getInstance ( user ). increment ( 2 );   // increment ONEPLUSONE:GAMES by 2  OneVsOneStats . GAMES . getInstance ( user ). decrement ();   // decrement ONEPLUSONE:GAMES by 1  OneVsOneStats . GAMES . getInstance ( user ). decrement ( 2 );   // decrement ONEPLUSONE:GAMES by 2  OneVsOneStats . GAMES . getInstance ( user ). getVal ();   // return the val of ONEPLUSONE:GAMES  OneVsOneStats . GAMES . getInstance ( user ). setVal ( 42 );   // set ONEPLUSONE:GAMES to 42   \nBe sure to also check out the  javadocs for statsinstance .", 
            "title": "Using the stats api"
        }, 
        {
            "location": "/contributor-area/general/", 
            "text": "Contributing to VoxelGamesLib\n\n\nHey there!\n\nThank for considering to contribute to VGL! Together we can make this thing even more\nawesome.\n\nThis area aims to be the central point for contributors and ppl who want to become one.\n\n\nThere are many ways you can contribute:  \n\n\n\n\nCreate Bugs Reports or Feature Requests\n\n  Found an issue? Wants something added? Help making VGL better with your ideas!\n\n  Learn more \nhere\n  \n\n\nContribute Translations\n\n  You are a walking dictionary or just generally good at languages? Consider helping\n  to translate this project so even more people can use it!  \n\n  Learn more \nhere\n  \n\n\nContribute Maps\n\n  Build a cool map you want to share with others so that more players can enjoy it?\n  Then this is for you!\n\n  Learn more \nhere\n  \n\n\nContribute Code\n\n  You want to help us out with your coding skills? Found out what you can do in this section!\n\n  Learn more \nhere\n  \n\n\n\n\nThis section also hosts the \ncontributors corner\n where news and other\nstuff that is relevant for contributors is posted.\n\n\nAnd our \"Hall of Fame\" of contributors is located in the other corner \nhere", 
            "title": "General"
        }, 
        {
            "location": "/contributor-area/general/#contributing-to-voxelgameslib", 
            "text": "Hey there! \nThank for considering to contribute to VGL! Together we can make this thing even more\nawesome. \nThis area aims to be the central point for contributors and ppl who want to become one.  There are many ways you can contribute:     Create Bugs Reports or Feature Requests \n  Found an issue? Wants something added? Help making VGL better with your ideas! \n  Learn more  here     Contribute Translations \n  You are a walking dictionary or just generally good at languages? Consider helping\n  to translate this project so even more people can use it!   \n  Learn more  here     Contribute Maps \n  Build a cool map you want to share with others so that more players can enjoy it?\n  Then this is for you! \n  Learn more  here     Contribute Code \n  You want to help us out with your coding skills? Found out what you can do in this section! \n  Learn more  here      This section also hosts the  contributors corner  where news and other\nstuff that is relevant for contributors is posted.  And our \"Hall of Fame\" of contributors is located in the other corner  here", 
            "title": "Contributing to VoxelGamesLib"
        }, 
        {
            "location": "/contributor-area/contributors/", 
            "text": "Contributors\n\n\nVoxelGamesLib was made possible by many community members.\n\nYou can view the full list for the projects on github,\nsee the main project here as an example:\n\nhttps://github.com/VoxelGamesLib/VoxelGamesLibv2/graphs/contributors\n\n\nThis page lists the major contributors and their role in the project.\n\n\n\n\nMiniDigger (\n)  \n\n\nRole: Founder and Maintainer  \n\n\nNotable contributions: General api design  \n\n\n\n\n\n\nLordRobust (aphelion)  \n\n\nRole: Maintainer, Addon Developer  \n\n\nNotable contributions: Chat System, API feedback, first addon  \n\n\n\n\n\n\nspammy24\n\n\nRole: Translator, Addon Developer\n\n\nNoteable contributions: spanish translation\n\n\n\n\n\n\nkashike\n\n\nRole: Problem solver\n\n\nNoteable contributions: Helping with various minor issues\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nFeeling like you made a major contribution? \nFeel free to open a pr and add yourself here!", 
            "title": "Contributors"
        }, 
        {
            "location": "/contributor-area/contributors/#contributors", 
            "text": "VoxelGamesLib was made possible by many community members. \nYou can view the full list for the projects on github,\nsee the main project here as an example: https://github.com/VoxelGamesLib/VoxelGamesLibv2/graphs/contributors  This page lists the major contributors and their role in the project.   MiniDigger ( )    Role: Founder and Maintainer    Notable contributions: General api design      LordRobust (aphelion)    Role: Maintainer, Addon Developer    Notable contributions: Chat System, API feedback, first addon      spammy24  Role: Translator, Addon Developer  Noteable contributions: spanish translation    kashike  Role: Problem solver  Noteable contributions: Helping with various minor issues      Tip  Feeling like you made a major contribution? \nFeel free to open a pr and add yourself here!", 
            "title": "Contributors"
        }, 
        {
            "location": "/contributor-area/contribute-code/", 
            "text": "Contributing code\n\n\nThis is probably the hardest way to contribute since you need to pass\na proper review and test of all your changes.\n\nBut as scary as this might look at first, it's really not. This document\naims to guide you through the process of opening a PR and make the process\nas easy as possible for everyone.\n\n\nIf you just spot this page, thats very unluck since it has no actual content\nyet.", 
            "title": "Contribute Code"
        }, 
        {
            "location": "/contributor-area/contribute-code/#contributing-code", 
            "text": "This is probably the hardest way to contribute since you need to pass\na proper review and test of all your changes. \nBut as scary as this might look at first, it's really not. This document\naims to guide you through the process of opening a PR and make the process\nas easy as possible for everyone.  If you just spot this page, thats very unluck since it has no actual content\nyet.", 
            "title": "Contributing code"
        }, 
        {
            "location": "/contributor-area/contribute-maps/", 
            "text": "Contribute Maps\n\n\nVGL has a public maps repository so that you can start your server without\nneeding to look for good maps first.\n\nYou can find the repo here \nhttps://github.com/VoxelGamesLib/maps\n\n\nIf you want to submit your map to that repository, just open a PR and fill\nout the information in the template (name, author, screenshot etc)", 
            "title": "Contribute Maps"
        }, 
        {
            "location": "/contributor-area/contribute-maps/#contribute-maps", 
            "text": "VGL has a public maps repository so that you can start your server without\nneeding to look for good maps first. \nYou can find the repo here  https://github.com/VoxelGamesLib/maps  If you want to submit your map to that repository, just open a PR and fill\nout the information in the template (name, author, screenshot etc)", 
            "title": "Contribute Maps"
        }, 
        {
            "location": "/contributor-area/contribute-translations/", 
            "text": "Contribute translations\n\n\nThis page will explain how you can contribute your translated string \nto the project so everybody can enjoy VGL in their native language.\n\n\nVGL uses POEditor. POEditor is a site that allows a community to easily contribute on translating a project. All you have to sign up on their site and request to join the VGL project. You then can choose a language and start translating away! You also can correct translations by others or use the comments under every string to discuss wording and stuff like that. \n(TODO insert links here)\n\n\nLanguage String format\n\n\nVGL has its own format for how you can format messages. It allows you to include text colors, text decorations, click and hover events and variables.\n\nThe parser for the messages was written to be as forgiving as possible, so small syntax errors (like forgetting to close a color tag) will still be rendered ingame, altho it might produce a different output as you might expect.", 
            "title": "Contribute Translations"
        }, 
        {
            "location": "/contributor-area/contribute-translations/#contribute-translations", 
            "text": "This page will explain how you can contribute your translated string \nto the project so everybody can enjoy VGL in their native language.  VGL uses POEditor. POEditor is a site that allows a community to easily contribute on translating a project. All you have to sign up on their site and request to join the VGL project. You then can choose a language and start translating away! You also can correct translations by others or use the comments under every string to discuss wording and stuff like that. \n(TODO insert links here)", 
            "title": "Contribute translations"
        }, 
        {
            "location": "/contributor-area/contribute-translations/#language-string-format", 
            "text": "VGL has its own format for how you can format messages. It allows you to include text colors, text decorations, click and hover events and variables. \nThe parser for the messages was written to be as forgiving as possible, so small syntax errors (like forgetting to close a color tag) will still be rendered ingame, altho it might produce a different output as you might expect.", 
            "title": "Language String format"
        }, 
        {
            "location": "/contributor-area/create-bug-reports-or-feature-requests/", 
            "text": "Creating bug reports or feature requests\n\n\nNo software is perfect, expecially in the early stages. VGL is still filled with minor bugs or is missing some nice features the team didn't come up with yet.\n\nWe need your help for that!  \n\n\nBug reports\n\n\nFound an issue? Had a crash? Let us know! You should report every ever so small annoyance you encounter. We trive to make o", 
            "title": "Create bug reports or feature requests"
        }, 
        {
            "location": "/contributor-area/create-bug-reports-or-feature-requests/#creating-bug-reports-or-feature-requests", 
            "text": "No software is perfect, expecially in the early stages. VGL is still filled with minor bugs or is missing some nice features the team didn't come up with yet. \nWe need your help for that!", 
            "title": "Creating bug reports or feature requests"
        }, 
        {
            "location": "/contributor-area/create-bug-reports-or-feature-requests/#bug-reports", 
            "text": "Found an issue? Had a crash? Let us know! You should report every ever so small annoyance you encounter. We trive to make o", 
            "title": "Bug reports"
        }, 
        {
            "location": "/contributor-area/contributors-corner/", 
            "text": "Contributors Corner\n\n\nThis page lists useful information for maintainers or other team members.\n\n\nIts currently empty.", 
            "title": "Contributor's Corner"
        }, 
        {
            "location": "/contributor-area/contributors-corner/#contributors-corner", 
            "text": "This page lists useful information for maintainers or other team members.  Its currently empty.", 
            "title": "Contributors Corner"
        }, 
        {
            "location": "/test/testpage/", 
            "text": "test page\n\n\nthis is a test page to test the capabilities of the used doc software and its extensions\n\n\n\n\nNote\n\n\ntest 1234\n\n\n\n\n\n\nQuote\n\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\nnulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\nmassa, nec semper lorem quam in massa.\n\n\n\n\n1\n2\n3\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n){\n\n\n    \nSystem\n.\nout\n.\nprintln\n(\nTEST!\n);\n\n\n}\n\n\n\n\n\n\n\n\"I suck at english\"\n1\n\n\n is on \n \nMan, these emoji are nice\n\n\n\n\n\n\n\n\n\n\nsome random footnote", 
            "title": "Test"
        }, 
        {
            "location": "/test/testpage/#test-page", 
            "text": "this is a test page to test the capabilities of the used doc software and its extensions   Note  test 1234    Quote  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\nnulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\nmassa, nec semper lorem quam in massa.   1\n2\n3 public   static   void   main ( String []   args ){       System . out . println ( TEST! );  }    \"I suck at english\" 1   is on    Man, these emoji are nice      some random footnote", 
            "title": "test page"
        }
    ]
}